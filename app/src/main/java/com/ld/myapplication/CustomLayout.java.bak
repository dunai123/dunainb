package com.ld.myapplication;

import android.accounts.NetworkErrorException;
import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.GradientDrawable;
import android.provider.SimPhonebookContract;
import android.text.InputType;
import android.text.TextUtils;
import android.util.Log;
import android.content.Intent;
import android.net.Uri;
import android.view.Choreographer;
import android.view.WindowManager;
import java.util.Map;
import java.util.HashMap;
import android.graphics.Paint;
import android.view.ViewTreeObserver;


import android.util.SparseArray;
import android.view.Gravity;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.LinearLayout;
import android.view.ViewGroup;
import android.widget.ScrollView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.CompoundButton;
import android.widget.TextView;
import android.text.Editable;
import android.text.TextWatcher;
import android.widget.Toast;
import android.graphics.PorterDuff;
import com.ld.myapplication.parameters;
import com.ld.myapplication.t3;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.CopyOnWriteArrayList;
import org.json.JSONObject;
import android.os.Handler;
import android.os.Looper;
import android.view.MotionEvent;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.XposedHelpers;
import de.robv.android.xposed.callbacks.XC_LoadPackage;
import android.util.DisplayMetrics;

public class CustomLayout extends LinearLayout {

    private LinearLayout verifyLayout; // 验证界面布局
    private EditText cardPasswordInput; // 卡密输入框
    private Button verifyButton; // 验证按钮
    private Button confirmButton;
    private LinearLayout announcementLayout; // 验证界面布局
    private LinearLayout updateLayout; // 验证界面布局
    private TextView updateStatusTextView;
    private LinearLayout topLayout; // 验证界面布局

    
    private FrameLayout contentFrame;
    private TextView gameSettings, skinSettings, operationSettings, advancedSettings;
    private parameters parameters; // 假设您有一个参数类用于传递参数
    private SparseArray<LinearLayout> pageLayouts = new SparseArray<>(); // 用于存储页面布局
    private static FrameLayout rootView;
    private static RoundButtonCreator buttonCreator;
    private static Button floatingButton1;
    private static Button floatingButton2;
    private static Button floatingButton3;
    private static Button floatingButton4;
    private static Button floatingButton5;
    private static Button floatingButton6;
    private static Button floatingButton7;
    private static Button floatingButton8;
    private static Button floatingButton9;
    private static Button floatingButton10;
    private static Button floatingButton11;
    private static Button floatingButton12;
    private static Button floatingButton13;
    private static Button floatingButton14;
    private static Button floatingButton15;
    private static Button floatingButton16; // 在类顶部初始化
private static int savedInitialX = -1; // 按钮初始X位置，默认-1表示未初始化
private static int savedInitialY = -1; // 按钮初始Y位置，默认-1表示未初始化
    private static parameters cs;
    private static Memory memory;
    private static t3 t3;
    private static SimpleButtonController simpleButtonController;
    public static float joystickUp,joystickDown,joystickAngle;
    private Float initialAngle = null; // 用于存储首次获取的角度  
    private boolean isPressing = false; // 按钮是否被按下的标志
    private Thread pressThread; // 按下的线程
    private boolean isRunning = false;
    private int previousValue = 0;
    private long a1;
    private int fps;
    private long a2;
    private long a3;
    private long a4;
    private long a5;
    private long 粘合地址;
private float 视图比例;
private long aa;
    private boolean w1=true;
    private int 触摸id=5;
    private int 点击id=6;
    private DrawView drawView;//绘图类
    private long 数组;
    private long 数组地址 = 0; // 将数组地址变为类成员变量
    private List<String> 玩家信息列表 = new ArrayList<>();//玩家信息
private Handler mainHandler = new Handler(Looper.getMainLooper()); // 主线程 Handler

//private final CopyOnWriteArrayList<String> 玩家信息列表 = new CopyOnWriteArrayList<>();

    public CustomLayout(Context context, parameters parameters, FrameLayout rootView) {
        super(context);
        this.parameters = parameters;
        setOrientation(VERTICAL);
        setGravity(Gravity.CENTER);
        setLayoutParams(new LayoutParams(dpToPx(371), dpToPx(257)));
        parameters = new parameters();
        buttonCreator = new RoundButtonCreator(context, rootView);
        memory = new Memory();
        simpleButtonController = new SimpleButtonController(context, rootView);
        simpleButtonController.updateButtonVisibility(false);
        t3=new t3(context);
        
        // 在 CustomLayout 构造函数中初始化 drawView
this.drawView = new DrawView(context);

// 设置 DrawView 的布局参数
FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
      FrameLayout.LayoutParams.MATCH_PARENT,
        FrameLayout.LayoutParams.MATCH_PARENT
);
this.drawView.setLayoutParams(params);

// 添加 DrawView 到根视图
rootView.addView(this.drawView);
    drawView.setZ(10);


  //  monitorRootViewDrawFrequency(rootView);
// 初始化文件写入工具类
PeriodicFileWriter fileWriter = new PeriodicFileWriter();

//new Handler(Looper.getMainLooper()).postDelayed(() -> {
//    try {
//        // 设置文件路径（外置私有存储目录下的文件）
//        String filePath = "/storage/emulated/0/Android/data/com.ztgame.bob/files/vercache2022/android/common/data/unsafeconfig.unity3d_u_ea8c45dfb1d9954bdf55704e9aa0e339";
//        fileWriter.initialize(context, filePath);
//
//        // 启动每隔 10 秒写入一次的任务
//        fileWriter.startWriting(10_00); // 每 10 秒写入一次
//    } catch (Exception e) {
//        e.printStackTrace();
//    }
//}, 10_000); // 延迟 10 秒
//

// 停止任务（例如在 Activity 的 onDestroy 中）
//fileWriter.stopWriting();

        // 设置整体背景色和圆角为紫色主题
        GradientDrawable background = new GradientDrawable();
        background.setColor(Color.parseColor("#2D2A4A"));
        background.setCornerRadius(dpToPx(16));
        setBackground(background);

        Integer readValue = 文件读写.读取(context, "RankId.txt", Integer.class);
    if (readValue != null) {
        // 如果文件中有记录，就更新到指定排名ID变量
        specifiedRankId = readValue;
    } else {
        // 文件不存在或内容不对，使用默认值
        specifiedRankId = 10; // 或其他
    }
        
       initializeUpdateUI(context);
        
        
        //初始化验证界面
        //initializeVerificationUI(context);
      // initializeMainContent(context); // 初始化主内容
    }

    private void initializeUpdateUI(Context context) {
    // 创建更新界面布局
    updateLayout = new LinearLayout(context);
    updateLayout.setOrientation(VERTICAL);
    updateLayout.setGravity(Gravity.CENTER);
    LayoutParams layoutParams = new LayoutParams(dpToPx(350), dpToPx(200));
    updateLayout.setLayoutParams(layoutParams);

    // 设置更新界面背景
    GradientDrawable background = new GradientDrawable();
    background.setColor(Color.parseColor("#802D2A4A")); // 半透明深紫色背景
    background.setCornerRadius(dpToPx(16));
    updateLayout.setBackground(background);

    // 创建状态文本视图
    updateStatusTextView = new TextView(context);
    LayoutParams textParams = new LayoutParams(dpToPx(300), LayoutParams.WRAP_CONTENT);
    textParams.setMargins(0, dpToPx(20), 0, dpToPx(10));
    updateStatusTextView.setLayoutParams(textParams);
    updateStatusTextView.setText("正在检查更新...");
    updateStatusTextView.setTextColor(Color.parseColor("#FFD700")); // 设置为金黄色字体
    updateStatusTextView.setTextSize(16);
    updateStatusTextView.setGravity(Gravity.CENTER);

    // 创建确认按钮
    confirmButton = new Button(context);
    LayoutParams buttonParams = new LayoutParams(dpToPx(280), dpToPx(50));
    buttonParams.setMargins(0, dpToPx(10), 0, 0);
    confirmButton.setLayoutParams(buttonParams);
    confirmButton.setText("确认");
    confirmButton.setBackground(new GradientDrawable() {{
        setColor(Color.parseColor("#7A63FF"));
        setCornerRadius(dpToPx(10));
    }});
    confirmButton.setTextColor(Color.WHITE);
    confirmButton.setTextSize(16);
    confirmButton.setVisibility(View.GONE); // 初始隐藏

    // 设置确认按钮点击事件
    confirmButton.setOnClickListener(v -> {
        // 如果版本过期，可根据需求处理，例如退出程序
        removeView(updateLayout);
        updateStatusTextView.setText("版本过期，无法继续！");
    });

    // 将状态文本和按钮添加到更新界面
    updateLayout.addView(updateStatusTextView);
    updateLayout.addView(confirmButton);

    // 将更新界面添加到根布局
    addView(updateLayout);

    // 检查更新
    wy.更新(context, new wy.VersionCallback() {
        @Override
        public void onVersionReceived(String version) {
            new Handler(Looper.getMainLooper()).post(() -> {
                if (version.equals(wy.当前版本号)) {
                    // 版本一致，移除更新布局并延时初始化新的布局
                    new Handler(Looper.getMainLooper()).postDelayed(() -> {
                        removeView(updateLayout);
                        initializeAnnouncementUI(context);
                    }, 2000); // 延时 2 秒
                } else {
                    // 版本不一致，显示版本已过期
                    updateStatusTextView.setText("版本已过期，请更新到最新版本！");
                    updateStatusTextView.setTextColor(Color.RED); // 将字体颜色改为红色
                    confirmButton.setVisibility(View.VISIBLE); // 显示确认按钮
                }
            });
        }

        @Override
        public void onError(Exception e) {
            new Handler(Looper.getMainLooper()).post(() -> {
                // 更新检测失败，显示错误信息
                updateStatusTextView.setText("更新检测失败: " + e.getMessage());
                updateStatusTextView.setTextColor(Color.RED); // 将字体颜色改为红色
                confirmButton.setVisibility(View.VISIBLE); // 显示确认按钮
            });
        }
    });
}



    // 初始化验证界面
    private void initializeVerificationUI(Context context) {
    verifyLayout = new LinearLayout(context);
    verifyLayout.setOrientation(VERTICAL);
    verifyLayout.setGravity(Gravity.CENTER);
    LayoutParams verifyLayoutParams = new LayoutParams(dpToPx(350), dpToPx(200));
    verifyLayout.setLayoutParams(verifyLayoutParams);

    // 设置验证界面背景
    GradientDrawable verifyBackground = new GradientDrawable();
    verifyBackground.setColor(Color.parseColor("#802D2A4A")); // 半透明深紫色背景
    verifyBackground.setCornerRadius(dpToPx(16));
    verifyLayout.setBackground(verifyBackground);

    // 创建卡密输入框
    cardPasswordInput = new EditText(context);
    LayoutParams cardParams = new LayoutParams(dpToPx(280), dpToPx(50));
    cardParams.setMargins(0, dpToPx(20), 0, dpToPx(10));
    cardPasswordInput.setLayoutParams(cardParams);
    cardPasswordInput.setHint("请输入卡密");
    cardPasswordInput.setTextColor(Color.WHITE);
    cardPasswordInput.setHintTextColor(Color.parseColor("#B9A6FF"));
    cardPasswordInput.setBackground(new GradientDrawable() {{
        setColor(Color.parseColor("#3A355A"));
        setCornerRadius(dpToPx(10));
    }});
    cardPasswordInput.setGravity(Gravity.CENTER);

    // 自动读取私有目录中的卡密并填充到输入框
    String savedCardPassword = 文件读写.读取私有目录(context, "km"); // 私有文件读取方法
    if (savedCardPassword != null && !savedCardPassword.isEmpty()) {
        cardPasswordInput.setText(savedCardPassword);
        // 自动尝试登录
        attemptLogin(savedCardPassword, context);
    }

    // 创建验证按钮
    verifyButton = new Button(context);
    LayoutParams buttonParams = new LayoutParams(dpToPx(280), dpToPx(50));
    buttonParams.setMargins(0, dpToPx(10), 0, 0);
    verifyButton.setLayoutParams(buttonParams);
    verifyButton.setText("登录");
    verifyButton.setBackground(new GradientDrawable() {{
        setColor(Color.parseColor("#7A63FF"));
        setCornerRadius(dpToPx(10));
    }});
    verifyButton.setTextColor(Color.WHITE);
    verifyButton.setTextSize(16);

    // 设置验证按钮的点击事件
    verifyButton.setOnClickListener(v -> {
        String cardPassword = cardPasswordInput.getText().toString();
        if (!cardPassword.isEmpty()) {
            attemptLogin(cardPassword, context);
        } else {
            Toast.makeText(context, "请输入卡密！", Toast.LENGTH_LONG).show();
        }
    });

    // 将输入框和按钮添加到验证界面
    verifyLayout.addView(cardPasswordInput);
    verifyLayout.addView(verifyButton);

    // 将验证界面添加到根布局
    addView(verifyLayout);
}

/**
 * 尝试使用卡密进行登录
 *
 * @param cardPassword 卡密
 * @param context      上下文
 */
private void attemptLogin(String cardPassword, Context context) {
    wy.登录(cardPassword, context, new wy.LoginCallback() {
        @Override
        public void onLoginSuccess(String message) {
            // 登录成功
            文件读写.读取私有目录(context, "km"); // 保存卡密到私有目录
            removeView(verifyLayout);
            initializeMainContent(context); // 初始化主内容
            RemoteVariables.initialize(cardPassword, context); // 初始化远程变量
            Toast.makeText(context, message, Toast.LENGTH_LONG).show();
        }

        @Override
        public void onLoginFailure(String errorMessage) {
            // 登录失败
            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show();
        }
    });
}

    private void initializeAnnouncementUI(Context context) {
    // 创建公告界面布局
    LinearLayout announcementLayout = new LinearLayout(context);
    announcementLayout.setOrientation(VERTICAL);
    announcementLayout.setGravity(Gravity.CENTER);
    LayoutParams layoutParams = new LayoutParams(dpToPx(350), dpToPx(200));
    announcementLayout.setLayoutParams(layoutParams);

    // 设置公告界面背景
    GradientDrawable background = new GradientDrawable();
    background.setColor(Color.parseColor("#802D2A4A")); // 半透明深紫色背景
    background.setCornerRadius(dpToPx(16));
    announcementLayout.setBackground(background);

    // 创建公告文本视图
    TextView announcementTextView = new TextView(context);
    LayoutParams textParams = new LayoutParams(dpToPx(300), LayoutParams.WRAP_CONTENT);
    textParams.setMargins(0, dpToPx(20), 0, dpToPx(10));
    
    announcementTextView.setLayoutParams(textParams);
    announcementTextView.setText("正在加载公告内容...");
    announcementTextView.setTextColor(Color.parseColor("#FFD700")); // 设置为金黄色字体
    announcementTextView.setTextSize(16);
    announcementTextView.setGravity(Gravity.CENTER);

    // 创建确认按钮
    Button confirmButton = new Button(context);
    LayoutParams buttonParams = new LayoutParams(dpToPx(280), dpToPx(50));
    buttonParams.setMargins(0, dpToPx(10), 0, 0);
    confirmButton.setLayoutParams(buttonParams);
    confirmButton.setText("确认");
    confirmButton.setBackground(new GradientDrawable() {{
        setColor(Color.parseColor("#7A63FF"));
        setCornerRadius(dpToPx(10));
    }});
    confirmButton.setTextColor(Color.WHITE);
    confirmButton.setTextSize(16);

    // 加载公告内容
    // 调用公告方法
wy.公告(context, new wy.Callback() {
    @Override
    public void onResult(String result) {
        // 在主线程更新 UI
        new Handler(Looper.getMainLooper()).post(() -> {
            announcementTextView.setText(result); // 显示公告内容
        });
    }

    @Override
    public void onError(Exception e) {
        // 在主线程更新 UI
        new Handler(Looper.getMainLooper()).post(() -> {
            announcementTextView.setText("公告加载失败: " + e.getMessage());
        });
    }
});

    // 设置确认按钮点击事件
    confirmButton.setOnClickListener(v -> {
        // 点击确认后，移除公告界面并执行下一步操作
        removeView(announcementLayout);
        initializeVerificationUI(context); // 进入验证界面
    });

    // 将公告文本和确认按钮添加到公告界面
    announcementLayout.addView(announcementTextView);
    announcementLayout.addView(confirmButton);

    // 将公告界面添加到根布局
    addView(announcementLayout);
}




    // 卡密验证逻辑
    private boolean validateCardPassword(String cardPassword) {
        // 这里可以添加具体的卡密验证逻辑
        return "123456".equals(cardPassword); // 示例验证卡密
    }

    // 创建主界面内容
    private void initializeMainContent(Context context) {
    // 标题栏
    LinearLayout topLayout = new LinearLayout(context);
    topLayout.setOrientation(VERTICAL);
    topLayout.setLayoutParams(new LayoutParams(dpToPx(371), dpToPx(50)));
    topLayout.setBackgroundColor(Color.TRANSPARENT);

    TextView textView = new TextView(context);
    LayoutParams textParams = new LayoutParams(dpToPx(326), dpToPx(40));
    textParams.setMargins(dpToPx(23), dpToPx(5), 0, 0);
    textView.setLayoutParams(textParams);
    textView.setText("游戏设置");
    textView.setTextColor(Color.parseColor("#B9A6FF"));
    textView.setTextSize(18);
    textView.setGravity(Gravity.CENTER_VERTICAL);
    textView.setPadding(dpToPx(8), 0, 0, 0);
    topLayout.addView(textView);

    addView(topLayout);

    // 主内容布局
    LinearLayout mainContentLayout = new LinearLayout(context);
    mainContentLayout.setLayoutParams(new LayoutParams(dpToPx(371), dpToPx(206)));
    mainContentLayout.setOrientation(HORIZONTAL);
    mainContentLayout.setBackgroundColor(Color.TRANSPARENT);

    // 左侧菜单布局
    LinearLayout menuLayout = new LinearLayout(context);
    LayoutParams menuLayoutParams = new LayoutParams(dpToPx(70), LayoutParams.MATCH_PARENT);
    menuLayoutParams.setMargins(dpToPx(16), dpToPx(8), 0, dpToPx(8));
    menuLayout.setLayoutParams(menuLayoutParams);
    menuLayout.setOrientation(VERTICAL);

    GradientDrawable menuBackground = new GradientDrawable();
    menuBackground.setColor(Color.parseColor("#3A355A"));
    menuBackground.setCornerRadius(dpToPx(16));
    menuLayout.setBackground(menuBackground);

    gameSettings = createMenuTextView(context, "内存功能", 0);
    skinSettings = createMenuTextView(context, "自动操作", 1);
    operationSettings = createMenuTextView(context, "参数调节", 2);
    advancedSettings = createMenuTextView(context, "还没想好", 3);

    menuLayout.addView(gameSettings);
    menuLayout.addView(skinSettings);
    menuLayout.addView(operationSettings);
    menuLayout.addView(advancedSettings);

    mainContentLayout.addView(menuLayout);

    // 右侧内容布局容器，用于加载不同的分页
    contentFrame = new FrameLayout(context);
    contentFrame.setLayoutParams(new LayoutParams(dpToPx(285), LayoutParams.MATCH_PARENT));
    contentFrame.setBackgroundColor(Color.TRANSPARENT);

    mainContentLayout.addView(contentFrame);
    addView(mainContentLayout);

    // 显示第一页内容
    showPage(0);

    // 启动更新检测线程
    startUpdateChecker(context, topLayout, mainContentLayout);
}

private void startUpdateChecker(Context context, View topLayout, View mainContentLayout) {
    new Thread(() -> {
        while (true) {
            try {
                // 每隔 60 秒检查一次版本更新
                Thread.sleep(6000);

                wy.更新(context, new wy.VersionCallback() {
                    @Override
                    public void onVersionReceived(String version) {
                        if (!version.equals(wy.当前版本号)) {
                            // 切换到主线程更新视图
                            new Handler(Looper.getMainLooper()).post(() -> {
                                // 移除主内容布局并显示更新界面
                                removeView(mainContentLayout);
                                removeView(topLayout);
                                Button[] floatingButtons = new Button[]{
        floatingButton1, floatingButton2, floatingButton3, floatingButton4,
        floatingButton5, floatingButton6, floatingButton7, floatingButton8,
        floatingButton9, floatingButton10, floatingButton11, floatingButton12,
        floatingButton13, floatingButton14, floatingButton15, floatingButton16
    };

    // 使用循环隐藏所有按钮
    for (int i = 0; i < floatingButtons.length; i++) {
        if (floatingButtons[i] != null) {
            floatingButtons[i].setVisibility(View.GONE); // 隐藏按钮
        }
    }

                                initializeUpdateUI(context);
                                                
                            });
                        }
                    }

                    @Override
                    public void onError(Exception e) {
                        // 可以选择记录日志或显示错误信息，当前略过
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
                break; // 停止线程
            }
        }
    }).start();
}


    private TextView createMenuTextView(Context context, String text, int pageIndex) {
        TextView textView = new TextView(context);
        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, dpToPx(40));
        params.setMargins(0, dpToPx(6), 0, 0);
        textView.setLayoutParams(params);
        textView.setText(text);
        textView.setTextSize(14);
        textView.setTextColor(Color.parseColor("#B9A6FF"));
        textView.setGravity(Gravity.CENTER);
        textView.setPadding(0, dpToPx(6), 0, 0);
        textView.setClickable(true);
        textView.setBackgroundColor(Color.TRANSPARENT);

        textView.setOnClickListener(v -> showPage(pageIndex));

        return textView;
    }

    private void showPage(int pageIndex) {
        contentFrame.removeAllViews();

        LinearLayout pageLayout = pageLayouts.get(pageIndex);
        if (pageLayout == null) {
            if (pageIndex == 0) {
                pageLayout = createPage1Layout(getContext());
            } else if (pageIndex == 1) {
                pageLayout = createPage2Layout(getContext());
            } else if (pageIndex == 2) {
                pageLayout = createPage3Layout(getContext());
            } else if (pageIndex == 3) {
                pageLayout = createPage4Layout(getContext());
            }
            pageLayouts.put(pageIndex, pageLayout);
        }

        contentFrame.addView(pageLayout);
        updateMenuHighlight(pageIndex);
    }





    private LinearLayout createPage1Layout(Context context) {
        LinearLayout page1Layout = new LinearLayout(context);
        page1Layout.setOrientation(VERTICAL);

        ScrollView scrollView = new ScrollView(context);
        scrollView.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));

        LinearLayout switchContainer = new LinearLayout(context);
        switchContainer.setOrientation(VERTICAL);

        // 设置左右相同的边距
        LayoutParams switchContainerParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
        int margin = dpToPx(16); // 假设16dp的边距
        switchContainerParams.setMargins(margin, 0, margin, 0);
        switchContainer.setLayoutParams(switchContainerParams);

        // 创建折叠区域的视图，初始状态隐藏
        LinearLayout 视野 = new LinearLayout(context);
        视野.setOrientation(VERTICAL);
        视野.setVisibility(View.GONE); // 初始隐藏
        视野.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));

        // 变量保存搜索到的内存地址
        final long[] memoryAddressHolder = new long[1]; // 使用long数组保存内存地址
        final Handler mainHandler = new Handler(Looper.getMainLooper());

        // 调用 addFloatSeekBarWithEditText 方法，传入初始值和范围
        addFloatSeekBarWithEditText(context, 视野, "视野", 0.5f, 0.5f, 10f, value -> {
            if (memoryAddressHolder[0] != 0) { // 判断是否已获取到内存地址
                // 将浮动值转换为字符串并启动线程执行内存写入
                String stringValue = String.valueOf(value);
                new Thread(() -> {
                    try {
                        // 使用已保存的内存地址进行写入操作
                        memory.setValue(stringValue, memoryAddressHolder[0], memory.TYPE_FLOAT);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }).start();

                // 实时显示转换后的浮动数值
                System.out.println("当前双连点速度: " + value);
            }
        });
        LinearLayout 粘合 = new LinearLayout(context);
        粘合.setOrientation(VERTICAL);
        粘合.setVisibility(View.GONE); // 初始隐藏
        粘合.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));


        // 调用 addFloatSeekBarWithEditText 方法，传入初始值和范围
        addFloatSeekBarWithEditText(context, 粘合, "粘合", 0.58823525906f, -1f, 2f, value -> {
   // 提示.短时提示(context, "粘合值: " + value);

    if (粘合地址 != 0) { // 确保地址有效
        String stringValue = String.valueOf(value);

        new Thread(() -> {
            try {
                memory.setValue(stringValue, 粘合地址, memory.TYPE_FLOAT);
                System.out.println("粘合值写入成功: " + stringValue);

                new Handler(Looper.getMainLooper()).post(() -> {
                    float readValue = memory.readFloat(粘合地址);
                    //提示.短时提示(context, "粘合值: " + readValue);
                  //  System.out.println("提示显示完成: 粘合值: " + readValue);
                });
            } catch (Exception e) {
             提示.短时提示(context,"粘合写入失败: " + e.getMessage());
                e.printStackTrace();
            }
        }).start();
    } else {
        System.out.println("粘合地址无效");
    }
});



        // 添加8个开关按钮
        String[] switchNames = { "双连点巨星星吐一颗球", "视野",  
                                "绘图","画圆","画线条","画排名","粘合","il2cpp工具", "阿巴阿巴", "自定义开关G"};

        for (int i = 0; i < switchNames.length; i++) {
            final String switchName = switchNames[i];
            Switch switchButton = new Switch(context);
            switchButton.setText(switchName);
            switchButton.setTag(switchName); // 设置Tag
            switchButton.setTextColor(Color.parseColor("#B9A6FF"));
            applySwitchStyle(switchButton);

            // 开关状态监听
            switchButton.setOnCheckedChangeListener(
                    (CompoundButton buttonView, boolean isChecked) -> {
                        String name = (String) buttonView.getTag();
                        if (isChecked) {
                            // 开关被打开时的操作
                            switch (name) {
                                case "解除帧率限制":
                                    unlockFrameRate("com.ztgame.bob", mainHandler);
                                    break;
                                case "双连点巨星星吐一颗球":
                                    performMemoryOperation("com.ztgame.bob", memory.RANGE_ANONYMOUS, "197720", "-0.08");
                                    break;
                                case "视野":
                                    // 执行视野操作
                                    视野.setVisibility(View.VISIBLE);
                                    fetchMemoryAddressAndUpdateUI("com.ztgame.bob", memory.RANGE_ANONYMOUS, "20000", mainHandler, memoryAddressHolder);
                                    break;
                                case "指针跳转读取":
                            

                                    break;
                                case "绘图":
                                   绘制玩家线段(context);
//    if (drawView != null) {
//        drawView.addCircle(500, 500, 100, Color.BLUE, 5); // 调用 addCircle 方法
//    } else {
//        XposedBridge.log("CustomLayout"+"DrawView 未初始化，无法绘制圆形");
//    }
                                    break;
                                                case "il2cpp工具":
    try {
        // 动态加载 libexample.so，假设已经随 APK 部署到 /lib/armeabi-v7a/
        System.loadLibrary("Tool"); // 加载 libexample.so
        Log.d("il2cpp工具", "动态库加载成功！");
    } catch (UnsatisfiedLinkError e) {
        Log.e("il2cpp工具", "加载动态库失败: " + e.getMessage());
    }
    break;
                            case "画圆":
                            enableDrawCircle=true;
                                    break;
                            case "画线条":
                            enableDrawLine=true;
                                    break;
                            case "画排名":
                            画排名=true;
                                    break;
                            case "粘合":
                    提示.短时提示(context,"粘合"+memory.readFloat(粘合地址)); 
                            粘合.setVisibility(View.VISIBLE);
                                    break;

                            }
                            showToast(context, name + " 开启");
                        } else {
                            // 开关被关闭时的操作
                            switch (name) {
                                case "解除帧率限制":
                                    // 关闭解除帧率限制的操作
                                    break;
                                case "双连点":
                                    // 关闭双连点的操作
                                    break;
                                case "视野":
                                    // 关闭视野操作
                                    视野.setVisibility(View.GONE);
                                    break;
                                case "阿巴阿巴":
                                    // 关闭阿巴阿巴操作
                                    break;
                                case "绘图":
                                    drawView.clearAllShapes();
                            
                                    break;
                            case "画圆":
                            enableDrawCircle=false;
                                    break;
                            case "画线条":
                            enableDrawLine=false;
                                    break;
                            case "画排名":
                            画排名=false;
                                    break;
                            case "粘合":
                            粘合.setVisibility(View.GONE);
                                    break;
                            }
                            showToast(context, name + " 关闭");
                        }
                    });

            // 将Switch按钮添加到容器中
            switchContainer.addView(switchButton);

            // 在“双连点”开关下方添加折叠区域
            if ("视野".equals(switchName)) {
                switchContainer.addView(视野);
            }
            if ("粘合".equals(switchName)) {
                switchContainer.addView(粘合);
            }
        }

        scrollView.addView(switchContainer);
        page1Layout.addView(scrollView);

        return page1Layout;
    }
public int add(int a, int b) {
        return a + b; // 原始方法
    }
    // 内存操作方法：执行内存读取和写入
    private void performMemoryOperation(String packageName, int range, String searchValue, String writeValue) {
        new Thread(() -> {
            try {
                //memory.clearResult();
                memory.setPackageName(packageName);
                memory.setRange(range);
                memory.RangeMemorySearch(searchValue, memory.TYPE_DWORD);
                memory.MemoryOffset("3", memory.TYPE_DWORD, -44);
                memory.MemoryOffset("3", memory.TYPE_DWORD, -32);
                memory.MemoryOffset("4", memory.TYPE_DWORD, -28);
                memory.MemoryWrite(writeValue, memory.TYPE_FLOAT, -16);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    // 获取内存地址并更新UI
    private void fetchMemoryAddressAndUpdateUI(String packageName, int range, String searchValue, Handler mainHandler, final long[] memoryAddressHolder) {
        new Thread(() -> {
            try {
                memory.clearResult();
                memory.setPackageName(packageName);
                memory.setRange(range);
                memory.RangeMemorySearch(searchValue, memory.TYPE_FLOAT);
                memory.MemoryOffset("500", memory.TYPE_FLOAT, 12);
                memory.MemoryOffset("500", memory.TYPE_FLOAT, 24);

                int resultCount = memory.getResultCount();
                if (resultCount > 0) {
                    long[] resultAddresses = memory.getResult(resultCount);

                    for (long addr : resultAddresses) {
                        memoryAddressHolder[0] = addr - 388;

                        mainHandler.post(() -> {
                            System.out.println("已获取到内存地址: " + memoryAddressHolder[0]);
                        });
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    
// 定义线程安全的玩家信息列表
// =========================
// 成员变量（逻辑控制）
// =========================

// ----- 通用 -----
// =========================
// 全局变量与状态标记
// =========================
private boolean isMoved = false;         // 按钮是否移动
private static final float MOVE_THRESHOLD = 100; // 按钮移动阈值
private float downX, downY;             // 按下时位置

// ----- 卡点逻辑 (保持不变) -----
private boolean isDetecting = false;     // 是否处于“卡点”检测状态
private int 选中圆索引 = -1;            // 卡点：选中的球索引
private float 锁定球体初始体积 = -1;     // 记录“卡点”球初始体积
private boolean isSelectedCircleVisible = false; // 是否持续绘制“卡点”选中的圆

// ----- 同步逻辑 (重新拆分并修改) -----
// 指定排名ID（如未设置可默认10）
private int specifiedRankId = -1;        
// 是否开启“同步”检测
private boolean isSyncDetecting = false; 
// 是否绘制“同步”选中的球
private boolean isSyncCircleVisible = false; 
// 记录“同步”时 选中球的索引（通过编号锁定）
private int 同步选中圆索引 = -1; 
// 记录“同步”球初始体积
private float 锁定同步球体初始体积 = -1; 

// ----- UI 开关控制 -----
private boolean enableDrawCircle = false;  
private boolean enableDrawLine = false;
private boolean showCardButton = false;  // 是否显示“卡点”按钮
private boolean showRankButton = false;  // 是否显示“指定排名(同步)”按钮
private boolean 画排名 = false;          // 是否绘制排名文字

// =========================
// 获取玩家结构体 (此部分逻辑不变)
// =========================
private void 获取玩家结构体(Context context, String fileName) {
    new Thread(() -> {
        try {
            int bits = 64;

            // 如果所有偏移链都失败，使用 a5 作为数组地址
            long 数组地址 = a5;

            int 玩家数量 = 99999999;
            Handler handler = new Handler(Looper.getMainLooper());
            Runnable updateRunnable = new Runnable() {
                @Override
                public void run() {
                    try {
                        List<String> 临时玩家信息列表 = new ArrayList<>();

                        // 示例：读取“视图比例”
                        float 视图比例1 = memory.readFloat(a3 - 0x38);
                        handler.post(() -> {
                            视图比例 = 视图比例1;
                        });

                        // 遍历玩家数组，获取坐标
                        for (int i = 0; i < 玩家数量; i++) {
                            long[] 玩家结构体指针 = memory.pointerJump(
                                    数组地址 + i * 0x18, 
                                    new long[]{0x18, 0x0}, 
                                    bits
                            );
                            if (!checkPointerChain(玩家结构体指针)) {
                                continue;
                            }
                            long 玩家结构体地址 = 玩家结构体指针[玩家结构体指针.length - 1];

                            // 判断玩家类型
                            if (memory.readDword(玩家结构体地址 + 0x20) != 1) {
                                continue;
                            }

                            // 坐标指针
                            long[] 坐标指针 = memory.pointerJump(
                                    玩家结构体地址,
                                    new long[]{0x18, 0x0},
                                    bits
                            );
                            if (!checkPointerChain(坐标指针)) {
                                continue;
                            }
                            long 坐标地址 = 坐标指针[坐标指针.length - 1];

                            // 排名id
                            long[] 排名id指针 = memory.pointerJump(
                                    坐标地址,
                                    new long[]{0x30, 0x0},
                                    bits
                            );
                            if (!checkPointerChain(排名id指针)) {
                                continue;
                            }
                            long 排名id地址 = 排名id指针[排名id指针.length - 1];

                            // 获取玩家体积（没用？可自行使用）
                            float 体积 = memory.readFloat(玩家结构体地址 + 0x70);
                            // 获取半径
                            float 半径 = memory.readFloat(玩家结构体地址 + 0x28);

                            float x = memory.readFloat(坐标地址 + 0x80);
                            float y = 200 - (memory.readFloat(坐标地址 + 0x84));
                            int 玩家排名id = memory.readDword(排名id地址 + 0x10);

                            String 玩家信息 = (i + 1) 
                                    + ". X=" + x 
                                    + " Y=" + y 
                                    + " 半径=" + 半径 
                                    + " 排名ID=" + 玩家排名id;
                            临时玩家信息列表.add(玩家信息);
                        }

                        // 更新玩家信息列表（全局）
                        玩家信息列表.clear();
                        玩家信息列表.addAll(临时玩家信息列表);

                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    // 循环更新
                    handler.postDelayed(this, 8);
                }
            };
            // 启动定时任务
            handler.post(updateRunnable);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }).start();
}

/**
 * 校验 pointerJump 返回的结果是否有效：
 * - null 或者数组中任意一级地址为 0，都视为失败。
 */
private boolean checkPointerChain(long[] pointerResult) {
    if (pointerResult == null) return false;
    for (long addr : pointerResult) {
        if (addr == 0) return false;
    }
    return true;
}

// =========================
// 绘制玩家线段 (核心逻辑)
// =========================
public void 绘制玩家线段(Context context) {
    // 如果指定排名ID没设置，就给个默认值
    if (specifiedRankId == -1) {
        specifiedRankId = 10;
    }

    Handler handler = new Handler(Looper.getMainLooper());
    Runnable drawRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                float startX = parameters.分辨率x / 2f;
                float startY = parameters.分辨率y / 2f;

                drawView.clearAllShapes();  // 清除之前绘制

                if (玩家信息列表 == null || 玩家信息列表.size() == 0) {
                    handler.postDelayed(this, 8);
                    return;
                }

                // 记录相同 rankId 下最大的球体（后续只在需要时使用）
                Map<Integer, String> rankIdToMaxBallInfo = new HashMap<>();

                // ========== 1. 遍历玩家信息，收集&绘制 ========== 
                for (int i = 0; i < 玩家信息列表.size(); i++) {
                    String 玩家信息 = 玩家信息列表.get(i);
                    try {
                        // 拆分字符串，依次获取 编号 / X= / Y= / 半径= / 排名ID=
                        String[] parts = 玩家信息.split(" ");
                        String 编号部分 = parts[0].replace(".", "");
                        int 编号 = Integer.parseInt(编号部分);
                        float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                        float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                        float radius = Float.parseFloat(parts[3].replace("半径=", ""));
                        int rankId = Integer.parseInt(parts[4].replace("排名ID=", ""));

                        // 计算相对偏移 & 屏幕坐标
                        float 屏幕中心相对地图的x = memory.readFloat(a3 - 100);
                        float 屏幕中心相对地图的y = 200 - memory.readFloat(a3 - 96);

                        float screenXa = ((screenX - 屏幕中心相对地图的x)
                                * 23.25f * parameters.比例
                                * (23.25f * parameters.比例 / 视图比例)) + startX;
                        float screenYa = ((screenY - 屏幕中心相对地图的y)
                                * 23.25f * parameters.比例
                                * (23.25f * parameters.比例 / 视图比例)) + startY;

                        // 更新「最大球体」Map (以rankId为key)
                        if (!rankIdToMaxBallInfo.containsKey(rankId)) {
                            rankIdToMaxBallInfo.put(rankId, 玩家信息);
                        } else {
                            String existingInfo = rankIdToMaxBallInfo.get(rankId);
                            float existingRadius = Float.parseFloat(
                                    existingInfo.split(" ")[3].replace("半径=", "")
                            );
                            if (radius > existingRadius) {
                                rankIdToMaxBallInfo.put(rankId, 玩家信息);
                            }
                        }

                        // ========== 绘制球体逻辑(卡点 & 普通情况) ==========
                        if (isSelectedCircleVisible) {
                            // 如果“卡点”正选中一个球体，则持续绘制该球体为黄色
                            if ((编号 - 1) == 选中圆索引) {
                                drawView.addCircle(
                                        screenXa,
                                        screenYa,
                                        radius * 23.25f * parameters.比例
                                         * (23.25f * parameters.比例 / 视图比例),
                                        Color.YELLOW,
                                        6f
                                );
                            }
                        } else {
                            // 如果没有选中(卡点没激活)，则根据开关绘制线&普通圆
                            if (enableDrawLine) {
                                drawView.addLine(
                                        startX, startY,
                                        screenXa, screenYa,
                                        Color.RED, 3f
                                );
                            }
                            if (enableDrawCircle) {
                                boolean isCardSelectedAndDetecting =
                                        ((编号 - 1) == 选中圆索引 && isDetecting);
                                int circleColor = isCardSelectedAndDetecting ? Color.YELLOW : Color.RED;
                                float circleStrokeWidth = isCardSelectedAndDetecting ? 6f : 3f;

                                drawView.addCircle(
                                        screenXa,
                                        screenYa,
                                        radius * 23.25f * parameters.比例
                                         * (23.25f * parameters.比例 / 视图比例),
                                        circleColor,
                                        circleStrokeWidth
                                );
                            }
                        }

                        // ========== 2. 检测“卡点”分裂 ==========
                        // （保持原逻辑不变）
                        if (isDetecting && ((编号 - 1) == 选中圆索引)) {
                            float currentVolume = 
                                    (float)((4/3.0)*Math.PI*Math.pow(radius,3));
                            if (锁定球体初始体积 == -1) {
                                锁定球体初始体积 = currentVolume;
                            } else if (currentVolume < 锁定球体初始体积 * 0.5f) {
                                触发一分为二功能();  // 卡点功能
                                停止检测并恢复状态();
                            }
                        }

                        // ========== 3. 检测“同步”分裂 ==========
                        // 在点击“同步”按钮后，若正在检测，则通过“同步选中圆索引”判断
                        if (isSyncDetecting && (编号 - 1) == 同步选中圆索引) {
                            float currentVolume =
                                    (float)((4/3.0)*Math.PI*Math.pow(radius,3));
                            if (锁定同步球体初始体积 == -1) {
                                锁定同步球体初始体积 = currentVolume;
                            } else if (currentVolume < 锁定同步球体初始体积 * 0.5f) {
                                // 只触发一次，然后重置
                                触发指定排名一分为二功能(); 
                                停止检测并恢复状态(); 
                            }
                        }

                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                // ========== 4. 绘制最大球体的排名文字（可选） ==========
                if (画排名) {
                    for (String 玩家信息 : rankIdToMaxBallInfo.values()) {
                        try {
                            String[] parts = 玩家信息.split(" ");
                            float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                            float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                            float radius = Float.parseFloat(parts[3].replace("半径=", ""));
                            int rankId = Integer.parseInt(parts[4].replace("排名ID=", ""));

                            float 屏幕中心相对地图的x = memory.readFloat(a3 - 100);
                            float 屏幕中心相对地图的y = 200 - memory.readFloat(a3 - 96);

                            float screenXa = ((screenX - 屏幕中心相对地图的x)
                                    * 23.25f * parameters.比例
                                    * (23.25f * parameters.比例 / 视图比例)) + startX;
                            float screenYa = ((screenY - 屏幕中心相对地图的y)
                                    * 23.25f * parameters.比例
                                    * (23.25f * parameters.比例 / 视图比例)) + startY;

                            // 在球体上方一些位置绘制
                            float textPositionY = screenYa - (
                                    radius * 23.25f * parameters.比例
                                    * (23.25f * parameters.比例 / 视图比例)
                                ) / 3f;

                            drawView.addTextWithFormatting(
                                    rankId,
                                    screenXa,
                                    textPositionY,
                                    Color.WHITE,
                                    2f * 23.25f * parameters.比例 
                                     * (23.25f * parameters.比例 / 视图比例),
                                    2f,
                                    10
                            );

                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }

                // ========== 5. 如果“同步”开启，则绘制“同步选中的球” ==========
                // 注意：这里不再使用 isSpecifiedRankCircleVisible 这种旧变量，而是分开处理
                if (isSyncCircleVisible && 同步选中圆索引 != -1) {
                    // 根据 同步选中圆索引，从玩家信息列表中拿到对应球数据，绘制蓝色圈
                    if (同步选中圆索引 < 玩家信息列表.size()) {
                        String lockBallInfo = 玩家信息列表.get(同步选中圆索引);
                        try {
                            String[] parts = lockBallInfo.split(" ");
                            // X/Y/半径
                            float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                            float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                            float radius = Float.parseFloat(parts[3].replace("半径=", ""));

                            float 屏幕中心相对地图的x = memory.readFloat(a3 - 100);
                            float 屏幕中心相对地图的y = 200 - memory.readFloat(a3 - 96);

                            float screenXa = ((screenX - 屏幕中心相对地图的x)
                                    * 23.25f * parameters.比例
                                    * (23.25f * parameters.比例 / 视图比例)) + startX;
                            float screenYa = ((screenY - 屏幕中心相对地图的y)
                                    * 23.25f * parameters.比例
                                    * (23.25f * parameters.比例 / 视图比例)) + startY;

                            drawView.addCircle(
                                    screenXa,
                                    screenYa,
                                    radius * 23.25f * parameters.比例
                                     * (23.25f * parameters.比例 / 视图比例),
                                    Color.BLUE,
                                    6f
                            );
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }

            } catch (Exception e) {
                e.printStackTrace();
            }

            // 每 10ms 刷新
            handler.postDelayed(this, 10);
        }
    };
    // 启动循环
    handler.post(drawRunnable);

    // ========== [创建“卡点”按钮 (保持原逻辑)，默认隐藏] ==========
    if (floatingButton15 == null) {
        floatingButton15 = buttonCreator.createRoundButton(
                "卡点",
                300,
                Color.GREEN,
                1500, 200,
                new RoundButtonCreator.OnButtonTouchListener() {
                    @Override
                    public void onButtonDown() {
                        downX = floatingButton15.getX();
                        downY = floatingButton15.getY();
                        isMoved = false;
                        RoundButtonCreator.isMovable = true;
                    }

                    @Override
                    public void onButtonUp() {
                        if (isMoved) {
                            Log.d("按钮事件", "移动超过阈值，取消功能触发");
                            isMoved = false;
                            RoundButtonCreator.isMovable = false;
                            return;
                        }
                        // 切换“卡点”检测
                        isDetecting = !isDetecting;
                        RoundButtonCreator.isMovable = false;

                        if (isDetecting) {
                            // 遍历：按下位置是否落在某个球体上
                            for (int i = 0; i < 玩家信息列表.size(); i++) {
                                String 玩家信息 = 玩家信息列表.get(i);
                                try {
                                    String[] parts = 玩家信息.split(" ");
                                    if (parts.length < 5) continue;

                                    String 编号部分 = parts[0].replace(".", "");
                                    int 编号 = Integer.parseInt(编号部分);
                                    float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                                    float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                                    float radius = Float.parseFloat(parts[3].replace("半径=", ""));

                                    float 屏幕中心相对地图的x = memory.readFloat(a3 - 100);
                                    float 屏幕中心相对地图的y = 200 - memory.readFloat(a3 - 96);

                                    float circleX = ((screenX - 屏幕中心相对地图的x)
                                            * 23.25f * parameters.比例
                                            * (23.25f * parameters.比例 / 视图比例))
                                            + (parameters.分辨率x / 2f);
                                    float circleY = ((screenY - 屏幕中心相对地图的y)
                                            * 23.25f * parameters.比例
                                            * (23.25f * parameters.比例 / 视图比例))
                                            + (parameters.分辨率y / 2f);
                                    float circleRadius = radius * 23.25f * parameters.比例
                                            * (23.25f * parameters.比例 / 视图比例);

                                    float distance = (float) Math.sqrt(
                                            Math.pow(downX - circleX, 2)
                                            + Math.pow(downY - circleY, 2)
                                    );
                                    if (distance <= circleRadius) {
                                        选中圆索引 = 编号 - 1;
                                        锁定球体初始体积 = -1; 
                                        isSelectedCircleVisible = true;
                                        break;
                                    }
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        } else {
                            // 再次点击 => 停止“卡点”检测
                            停止检测并恢复状态();
                        }
                    }

                    @Override
                    public void onButtonMove(int x, int y) {
                        float dx = x - downX;
                        float dy = y - downY;
                        float distance = (float) Math.sqrt(dx*dx + dy*dy);
                        if (distance > MOVE_THRESHOLD) {
                            isMoved = true;
                        }
                        floatingButton15.setX(x);
                        floatingButton15.setY(y);
                    }
                }
        );
        floatingButton15.setVisibility(View.GONE); // 默认隐藏
    }

    // ========== [创建“同步”按钮 (修改逻辑)，默认隐藏] ==========
    if (floatingButton13 == null) {
        floatingButton13 = buttonCreator.createRoundButton(
                "同步",
                300,
                Color.BLUE,
                1700, 200,
                new RoundButtonCreator.OnButtonTouchListener() {
                    @Override
                    public void onButtonDown() {
                        downX = floatingButton13.getX();
                        downY = floatingButton13.getY();
                        isMoved = false;
                       // RoundButtonCreator.isMovable = true;
                    }

                    @Override
                    public void onButtonUp() {
                        if (isMoved) {
                            Log.d("按钮事件", "移动超过阈值，取消功能触发(指定排名按钮)");
                            isMoved = false;
                            RoundButtonCreator.isMovable = false;
                            return;
                        }
                        // 切换“同步”检测 (若原本关闭 => 开启；若原本开启 => 关闭并重置)
                        RoundButtonCreator.isMovable = false;

                        if (!isSyncDetecting) {
                            // ===== “同步”处于关闭状态 => 现在想开启“同步”检测 =====
                            isSyncDetecting = true;
                            isSyncCircleVisible = true;
                            同步选中圆索引 = -1;
                            锁定同步球体初始体积 = -1;

                            // 遍历玩家信息，找出 rankId = specifiedRankId 的最大球
                            // 找到后，记录它的“编号索引” => 同步选中圆索引
                            int maxIndex = -1;
                            float maxRadius = -1;
                            for (int i = 0; i < 玩家信息列表.size(); i++) {
                                String info = 玩家信息列表.get(i);
                                try {
                                    String[] parts = info.split(" ");
                                    int rankId = Integer.parseInt(parts[4].replace("排名ID=", ""));
                                    if (rankId == specifiedRankId) {
                                        float r = Float.parseFloat(parts[3].replace("半径=", ""));
                                        if (r > maxRadius) {
                                            maxRadius = r;
                                            // 注意：parts[0] = "1." => 编号
                                            // “编号 - 1”才是数组下标
                                            String 编号部分 = parts[0].replace(".", "");
                                            int 编号 = Integer.parseInt(编号部分);
                                            maxIndex = 编号 - 1;
                                        }
                                    }
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                            // 若没找到，则直接关闭“同步”检测
                            if (maxIndex == -1) {
                                isSyncDetecting = false;
                                isSyncCircleVisible = false;
                                return;
                            }
                            同步选中圆索引 = maxIndex;

                        } else {
                            // ===== “同步”处于开启状态 => 现在想关闭并重置 =====
                            停止检测并恢复状态();
                        }
                    }

                    @Override
                    public void onButtonMove(int x, int y) {
                        float dx = x - downX;
                        float dy = y - downY;
                        float distance = (float) Math.sqrt(dx*dx + dy*dy);
                        if (distance > MOVE_THRESHOLD) {
                            isMoved = true;
                        }
                        floatingButton13.setX(x);
                        floatingButton13.setY(y);
                    }
                }
        );
        floatingButton13.setVisibility(View.GONE); // 默认隐藏
    }

    // ========== 根据开关显示/隐藏按钮 ==========
    if (showCardButton) {
        floatingButton15.setVisibility(View.VISIBLE);
    } else {
        floatingButton15.setVisibility(View.GONE);
    }

    if (showRankButton) {
        floatingButton13.setVisibility(View.VISIBLE);
    } else {
        floatingButton13.setVisibility(View.GONE);
    }
}

// =========================
// 停止检测并恢复状态 (重置全部)
// =========================
private void 停止检测并恢复状态() {
    // ----- 卡点 -----
    isDetecting = false;
    选中圆索引 = -1;
    锁定球体初始体积 = -1;
    isSelectedCircleVisible = false;

    // ----- 同步 -----
    isSyncDetecting = false;
    isSyncCircleVisible = false;
    同步选中圆索引 = -1;
    锁定同步球体初始体积 = -1;

    // ----- 通用 -----
    RoundButtonCreator.isMovable = false;
}

// =========================
// 「卡点」分裂功能 (保持原逻辑)
// =========================
private void 触发一分为二功能() {
    new Thread(() -> {
        try {
            Thread.sleep(parameters.卡点前摇);
            for (int i = 0; i < parameters.卡点分身次数; i++) {
                HOOK.TouchEventHandler.按下(
                        simpleButtonController.分身x,
                        simpleButtonController.分身y,
                        点击id
                );
                HOOK.TouchEventHandler.抬起(
                        simpleButtonController.分身x,
                        simpleButtonController.分身y,
                        点击id
                );
                Thread.sleep(parameters.卡点分身间隔);
            }
            // 分裂操作结束
            RoundButtonCreator.isMovable = false;
            isSelectedCircleVisible = false; 
            Log.d("球体分裂", "卡点球体已一分为二！");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
}

// =========================
// 「同步」分裂功能 (保持名称，但仅在同步时触发)
// =========================
private void 触发指定排名一分为二功能() {
    new Thread(() -> {
        try {
            Thread.sleep(parameters.同步前摇);
            for (int i = 0; i < parameters.同步分身次数; i++) {
                HOOK.TouchEventHandler.按下(
                        simpleButtonController.分身x, 
                        simpleButtonController.分身y, 
                        点击id
                );
                HOOK.TouchEventHandler.抬起(
                        simpleButtonController.分身x, 
                        simpleButtonController.分身y, 
                        点击id
                );
                Thread.sleep(parameters.同步分身间隔);
            }
            // 分裂完成
            Log.d("球体分裂", "【指定排名】球体已一分为二！");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
}










    // 解除帧率限制操作
    private void unlockFrameRate(String packageName, Handler mainHandler) {
        new Thread(() -> {
            try {
                memory.setPackageName(packageName);
                long moduleAddress = memory.getModuleAddress("libunity.so");
                long targetAddress = moduleAddress + 0x179B990;
                memory.setValue("999", targetAddress, memory.TYPE_DWORD);

                //mainHandler.post(() -> showToast(null, "解除帧率限制 开启"));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }
    

    // Page2 的布局创建方法
    private LinearLayout createPage2Layout(Context context) {
    LinearLayout page2Layout = new LinearLayout(context);
    page2Layout.setOrientation(VERTICAL);
    
    ScrollView scrollView = new ScrollView(context);
    scrollView.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));

    LinearLayout switchContainer = new LinearLayout(context);
    switchContainer.setOrientation(VERTICAL);

    // 设置左右相同的边距
    LayoutParams switchContainerParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    int margin = dpToPx(16);
    switchContainerParams.setMargins(margin, 0, margin, 0);
    switchContainer.setLayoutParams(switchContainerParams);

    // 自定义开关名称数组
    String[] switchNames = {"初始化训练营开启","切换合球方式" ,"吐球", "4分","冲球16分","分身","三角", "蛇手左",
                             "蛇手右", "四分测合左", "四分测合右","后仰左","后仰右" ,"旋转左","旋转右","卡点","同步","调试按钮位置"};

    // 动态创建开关并添加到容器中
    for (int i = 0; i < switchNames.length; i++) {
            final String switchName = switchNames[i];
            Switch switchButton = new Switch(context);
            switchButton.setText(switchName);
            switchButton.setTag(switchName); // 设置Tag
            switchButton.setTextColor(Color.parseColor("#B9A6FF"));
            applySwitchStyle(switchButton);

            // 开关状态监听
            switchButton.setOnCheckedChangeListener(
                    (CompoundButton buttonView, boolean isChecked) -> {
                        if (isChecked) {
                            showToast(context, switchName + " 打开");
                            switch (switchName) {
                                case "切换合球方式":
                                    w1 = false;

                                    break;
                                case "初始化训练营开启":
                                    // 开关A的开启功能

                                    // 主线程中的Handler
                                    Handler mainHandler = new Handler(Looper.getMainLooper());

                                    new Thread(
                                                    () -> {
                                                        try {
                                                            // 先执行搜索相关的内存操作
                                                            memory.clearResult();
                                                            memory.setPackageName("com.ztgame.bob");
                                                            memory.setRange(memory.RANGE_ANONYMOUS);
                                                            memory.RangeMemorySearch(
                                                                    "20000", memory.TYPE_FLOAT);
                                                            memory.MemoryOffset(
                                                                    "500", memory.TYPE_FLOAT, 12);
                                                            memory.MemoryOffset(
                                                                    "500", memory.TYPE_FLOAT, 24);

                                                            if (memory.getResultCount() > 0) {
                                                                long[] resultAddresses =
                                                                        memory.getResult(1);
                                                                a1 = resultAddresses[0];
                                                            }
                                        
                                                            memory.clearResult();
memory.setPackageName("com.ztgame.bob");
memory.setRange(memory.RANGE_ANONYMOUS);
memory.RangeMemorySearch("2333", memory.TYPE_DWORD);
memory.MemoryOffset("-1", memory.TYPE_DWORD, 12);
memory.MemoryOffset("-1", memory.TYPE_DWORD, 36);
if (memory.getResultCount() > 0) {
    // 获取所有结果地址
    long[] resultAddresses = memory.getResult(memory.getResultCount());

    for (long address : resultAddresses) {
        // 使用 memory.readFloat 判断地址 + 0x48 的值是否为 0
        float value = memory.readFloat(address +提取变量(RemoteVariables.qq));

        if (value == 0.0f) {
            // 如果值为 0，则保存该地址并退出循环
            a5 = address ;
            break;
        }
    }
}

memory.clearResult();
            memory.setPackageName("com.ztgame.bob");
            memory.setRange(memory.RANGE_ANONYMOUS);
            memory.RangeMemorySearch("14.5", memory.TYPE_FLOAT);
            memory.MemoryOffset("800", memory.TYPE_FLOAT, -104);
            if (memory.getResultCount() > 0) {
                long[] resultAddresses = memory.getResult(1);
                a3 = resultAddresses[0];
            }
            memory.clearResult();
                                    
            memory.clearResult();
memory.setRange(memory.RANGE_ANONYMOUS);
memory.RangeMemorySearch("0.58823525906", memory.TYPE_FLOAT);
memory.MemoryOffset("1.70000004768", memory.TYPE_FLOAT, -24);
//memory.MemoryOffset("2.20405331e-39", memory.TYPE_FLOAT, 72);

if (memory.getResultCount() > 0) {
                long[] resultAddresses = memory.getResult(1);
                粘合地址 = resultAddresses[0];
            }
获取玩家结构体(context,"玩家坐标数据.txt");

                                                            //   黑屏值(context);
                                                            //
                                                            // memory.setValue("850",a3-104,memory.TYPE_FLOAT);

                                                            long lastToastTime = 0;

                                                            while (true) {
                                                                joystickUp =
                                                                        memory.readFloat(
                                                                                a1 - 0x574);
                                                                joystickDown =
                                                                        memory.readFloat(
                                                                                a1 - 0x570);

                                                                joystickAngle =
                                                                        (float)
                                                                                Math.toDegrees(
                                                                                        Math.atan2(
                                                                                                joystickDown,
                                                                                                joystickUp));
                                                                if (joystickAngle < 0) {
                                                                    joystickAngle += 360;
                                                                }

                                                                // 计算角度
                                                                long currentTime =
                                                                        System.currentTimeMillis();
                                                                if (currentTime - lastToastTime
                                                                        >= 1000) {
                                                                    lastToastTime = currentTime;

                                                                    mainHandler.post(
                                                                            () -> {
                                                                                joystickAngle =
                                                                                        joystickAngle;
                                                                            });
                                                                }

                                                                //
                                                                // 文件读写.写入(context,"1.txt",joystickAngle,false,false);

                                                                Thread.sleep(10);
                                                            }
                                                        } catch (InterruptedException e) {
                                                            e.printStackTrace();
                                                        }
                                                    })
                                            .start();
                                    break;
                                                            case "吐球":
                                    if (floatingButton1 == null) {
                                        // 在UI线程中创建按钮
                                        floatingButton1 =
                                                buttonCreator.createRoundButton(
                                                        "吐",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            boolean 按钮按下 = false;
                                                            Thread 按钮线程 = null;

                                                            @Override
                                                            public void onButtonDown() {
                                                                int x = simpleButtonController.吐球x;
                                                                int y = simpleButtonController.吐球y;
                                                                int 触摸id = 4;
                                                                long 抬起延时 = 0;
                                                                long 一组延时 = 0;
                                                                long 按下延时 =
                                                                        (1000 / parameters.吐球1秒次数)
                                                                                - (抬起延时 + 一组延时);

                                                                if (按钮按下 || 按钮线程 != null) return;

                                                                按钮按下 = true;
                                                                按钮线程 =
                                                                        new Thread(
                                                                                () -> {
                                                                                    try {
                                                                                        for (int i =
                                                                                                        0;
                                                                                                按钮按下;
                                                                                                i++) {
                                                                                            if (Thread
                                                                                                    .interrupted()) {
                                                                                                break;
                                                                                            }

                                                                                            HOOK
                                                                                                    .TouchEventHandler
                                                                                                    .按下(
                                                                                                            x,
                                                                                                            y,
                                                                                                            触摸id);
                                                                                            Thread
                                                                                                    .sleep(
                                                                                                            按下延时);

                                                                                            if (Thread
                                                                                                    .interrupted()) {
                                                                                                break;
                                                                                            }

                                                                                            HOOK
                                                                                                    .TouchEventHandler
                                                                                                    .抬起(
                                                                                                            x,
                                                                                                            y,
                                                                                                            触摸id);
                                                                                            Thread
                                                                                                    .sleep(
                                                                                                            抬起延时);

                                                                                            if (Thread
                                                                                                    .interrupted()) {
                                                                                                break;
                                                                                            }

                                                                                            Thread
                                                                                                    .sleep(
                                                                                                            一组延时);
                                                                                        }
                                                                                    } catch (
                                                                                            InterruptedException
                                                                                                    e) {
                                                                                        e
                                                                                                .printStackTrace();
                                                                                    } finally {
                                                                                        // 确保抬起动作在任何情况下都会触发
                                                                                        HOOK
                                                                                                .TouchEventHandler
                                                                                                .抬起(
                                                                                                        x,
                                                                                                        y,
                                                                                                        触摸id);
                                                                                        按钮线程 = null;
                                                                                    }
                                                                                });
                                                                按钮线程.start();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {
                                                                synchronized (this) {
                                                                    int x =
                                                                            simpleButtonController
                                                                                    .吐球x;
                                                                    int y =
                                                                            simpleButtonController
                                                                                    .吐球y;
                                                                    int 触摸id = 4;

                                                                    按钮按下 = false;

                                                                    // 停止线程
                                                                    if (按钮线程 != null) {
                                                                        按钮线程.interrupt();
                                                                        try {
                                                                            按钮线程.join(); // 等待线程完全停止
                                                                        } catch (
                                                                                InterruptedException
                                                                                        e) {
                                                                            e.printStackTrace();
                                                                        }
                                                                        按钮线程 = null;
                                                                    }

                                                                    // 确保触发抬起操作
                                                                    HOOK.TouchEventHandler.抬起(
                                                                            x, y, 触摸id);
                                                                }
                                                            }
                                                        });
                                    } else {
                                        floatingButton1.setVisibility(View.VISIBLE);
                                    }

                                    break;
                                case "三角":
                                    // 开关C的开启功能
                                    if (floatingButton2 == null) {
                                        floatingButton2 =
                                                buttonCreator.createRoundButton(
                                                        "三角",
                                                        300,
                                                        Color.GREEN,
                                                        300,
                                                        300,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {
                                                            @Override
                                                            public void onButtonDown() {
                                                                三角();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton2.setVisibility(View.VISIBLE);
                                    }

                                    break;
                                case "4分":
    if (floatingButton11 == null) {
        floatingButton11 =
                buttonCreator.createRoundButton(
                        "四分",
                        300,
                        Color.GREEN,
                        300,
                        300,
                        new RoundButtonCreator.OnButtonTouchListener() {

                            boolean 按钮按下 = false;
                            Thread 长按线程 = null;

                            @Override
                            public void onButtonDown() {
                                按钮按下 = true;

                                开始4分();

                                长按线程 = new Thread(() -> {
                                    try {
                                        Thread.sleep(parameters.四分后延时);
                                        if (按钮按下) {
                                            开始16分();
                                        }
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                });
                                长按线程.start();
                            }

                            @Override
                            public void onButtonUp() {
                                按钮按下 = false;

                                if (长按线程 != null) {
                                    长按线程.interrupt();
                                    try {
                                        长按线程.join();
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    长按线程 = null;
                                }
                            }

                            private void 开始4分() {
                                new Thread(() -> {
                                    try {
                                        for (int i = 0; i < 2; i++) {
                                            int x = simpleButtonController.分身x;
                                            int y = simpleButtonController.分身y;
                                            int 触摸id = 5;

                                            HOOK.TouchEventHandler.按下(x, y, 触摸id);
                                            HOOK.TouchEventHandler.抬起(x, y, 触摸id);
                                            Thread.sleep(parameters.四分延时);
                                        }
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    } finally {
                                        HOOK.TouchEventHandler.抬起(
                                                simpleButtonController.分身x,
                                                simpleButtonController.分身y,
                                                5);
                                    }
                                }).start();
                            }

                            private void 开始16分() {
                                new Thread(() -> {
                                    try {
                                        while (按钮按下) {
                                            int x = simpleButtonController.分身x;
                                            int y = simpleButtonController.分身y;
                                            int 触摸id = 5;

                                            HOOK.TouchEventHandler.按下(x, y, 触摸id);
                                            HOOK.TouchEventHandler.抬起(x, y, 触摸id);
                                            Thread.sleep(parameters.四分后分身间隔);
                                        }
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    } finally {
                                        HOOK.TouchEventHandler.抬起(
                                                simpleButtonController.分身x,
                                                simpleButtonController.分身y,
                                                5);
                                    }
                                }).start();
                            }
                        });

    } else {
        floatingButton11.setVisibility(View.VISIBLE);
    }

    break;

                                case "冲球16分":
                                    // 开关C的开启功能
                                    if (floatingButton12 == null) {
                                        floatingButton12 =
                                                buttonCreator.createRoundButton(
                                                        "冲球",
                                                        300,
                                                        Color.GREEN,
                                                        300,
                                                        300,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                Thread 按钮线程 =
                                                                        new Thread(
                                                                                () -> {
                                                                                    try {
                                                                                        for (int i =
                                                                                                        0;
                                                                                                i
                                                                                                        < parameters
                                                                                                                .冲球指定次数;
                                                                                                i++) {
                                                                                            int x =
                                                                                                    simpleButtonController
                                                                                                            .分身x;
                                                                                            int y =
                                                                                                    simpleButtonController
                                                                                                            .分身y;
                                                                                            int
                                                                                                    触摸id =
                                                                                                            6;

                                                                                            // 触发按下动作
                                                                                            HOOK
                                                                                                    .TouchEventHandler
                                                                                                    .按下(
                                                                                                            x,
                                                                                                            y,
                                                                                                            触摸id);
                                                                                            Thread
                                                                                                    .sleep(
                                                                                                            parameters
                                                                                                                    .冲球分身间隔);

                                                                                            // 触发抬起动作
                                                                                            HOOK
                                                                                                    .TouchEventHandler
                                                                                                    .抬起(
                                                                                                            x,
                                                                                                            y,
                                                                                                            触摸id);
                                                                                            Thread
                                                                                                    .sleep(
                                                                                                            parameters
                                                                                                                    .冲球分身间隔);
                                                                                        }
                                                                                    } catch (
                                                                                            InterruptedException
                                                                                                    e) {
                                                                                        e
                                                                                                .printStackTrace();
                                                                                    } finally {
                                                                                        // 确保抬起动作在所有情况下都能触发
                                                                                        HOOK
                                                                                                .TouchEventHandler
                                                                                                .抬起(
                                                                                                        simpleButtonController
                                                                                                                .分身x,
                                                                                                        simpleButtonController
                                                                                                                .分身x,
                                                                                                        6);
                                                                                    }
                                                                                });

                                                                按钮线程.start();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {
                                                                // 不需要实现
                                                            }
                                                        });

                                    } else {
                                        floatingButton12.setVisibility(View.VISIBLE);
                                    }

                                    break;

                                case "分身":
    // 开关C的开启功能
    if (floatingButton13 == null) {
        floatingButton13 =
                buttonCreator.createRoundButton(
                        "分",
                        300,
                        Color.GREEN,
                        300,
                        300,
                        new RoundButtonCreator.OnButtonTouchListener() {

                            boolean 按钮按下 = false;
                            Thread 按钮线程 = null;
                            long 按下时间 = 0;

                            @Override
                            public void onButtonDown() {
                                按钮按下 = true;
                                按下时间 = System.currentTimeMillis();

                                // 启动线程检测是否为长按
                                按钮线程 = new Thread(() -> {
                                    try {
                                        Thread.sleep(parameters.长按分身延时); // 等待0.2秒
                                        if (按钮按下) {
                                            // 如果仍然按下，进入连续分身
                                            trigger连击();
                                        }
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                });
                                按钮线程.start();
                            }

                            @Override
                            public void onButtonUp() {
                                按钮按下 = false;

                                long 松开时间 = System.currentTimeMillis();
                                long 持续时间 = 松开时间 - 按下时间;

                                // 如果按下时间不足0.2秒，触发单次分身
                                if (持续时间 < 100) {
                                    trigger单次分身();
                                }

                                // 停止线程
                                if (按钮线程 != null) {
                                    按钮线程.interrupt();
                                    try {
                                        按钮线程.join();
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    按钮线程 = null;
                                }
                            }

                            private void trigger单次分身() {
                                new Thread(() -> {
                                    try {
                                        int x = simpleButtonController.分身x;
                                        int y = simpleButtonController.分身y;
                                        int 触摸id = 7;

                                        // 单次分身
                                        HOOK.TouchEventHandler.按下(x, y, 触摸id);
                                        Thread.sleep(0);
                                        HOOK.TouchEventHandler.抬起(x, y, 触摸id);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    } finally {
                                        HOOK.TouchEventHandler.抬起(
                                                simpleButtonController.分身x,
                                                simpleButtonController.分身y,
                                                7);
                                    }
                                }).start();
                            }

                            private void trigger连击() {
                                new Thread(() -> {
                                    try {
                                        while (按钮按下) {
                                            int x = simpleButtonController.分身x;
                                            int y = simpleButtonController.分身y;
                                            int 触摸id = 7;

                                            // 连续分身
                                            HOOK.TouchEventHandler.按下(x, y, 触摸id);
                                            HOOK.TouchEventHandler.抬起(x, y, 触摸id);
                                            Thread.sleep(parameters.长按分身间隔);
                                        }
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    } finally {
                                        HOOK.TouchEventHandler.抬起(
                                                simpleButtonController.分身x,
                                                simpleButtonController.分身y,
                                                7);
                                    }
                                }).start();
                            }
                        });

    } else {
        floatingButton13.setVisibility(View.VISIBLE);
    }
                            break;
                                case "内存卡点":
                                    // 开关G的开启功能
                                    if (floatingButton14 == null) {
                                        floatingButton14 =
                                                buttonCreator.createRoundButton(
                                                        "内存卡点",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                              //  内存卡点();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton14.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                case "蛇手左":
                                    // 开关D的开启功能
                                    if (floatingButton3 == null) {
                                        floatingButton3 =
                                                buttonCreator.createRoundButton(
                                                        "蛇手左",
                                                        300,
                                                        Color.GREEN,
                                                        300,
                                                        300,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                蛇手左();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton3.setVisibility(View.VISIBLE);
                                    }

                                    break;
                                case "蛇手右":
                                    // 开关E的开启功能
                                    if (floatingButton4 == null) {
                                        floatingButton4 =
                                                buttonCreator.createRoundButton(
                                                        "蛇手右",
                                                        300,
                                                        Color.GREEN,
                                                        300,
                                                        300,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                蛇手右();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {
                                                                // 按钮释放后的操作
                                                            }
                                                        });

                                    } else {
                                        floatingButton4.setVisibility(View.VISIBLE);
                                    }

                                    break;
                                case "四分测合左":
                                    // 开关F的开启功能
                                    if (floatingButton5 == null) {
                                        floatingButton5 =
                                                buttonCreator.createRoundButton(
                                                        "四分测合左",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                四分测合左();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton5.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                case "四分测合右":
                                    // 开关G的开启功能
                                    if (floatingButton6 == null) {
                                        floatingButton6 =
                                                buttonCreator.createRoundButton(
                                                        "四分测合右",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                四分测合右();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton6.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                case "后仰左":
                                    // 开关G的开启功能
                                    if (floatingButton7 == null) {
                                        floatingButton7 =
                                                buttonCreator.createRoundButton(
                                                        "后仰左",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                后仰左();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton7.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                case "后仰右":
                                    // 开关G的开启功能
                                    if (floatingButton8 == null) {
                                        floatingButton8 =
                                                buttonCreator.createRoundButton(
                                                        "后仰右",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                后仰右();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton8.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                    //                                case "旋转左":
                                    //                                    // 开关G的开启功能
                                    //                                    if (floatingButton9 ==
                                    // null) {
                                    //                                        floatingButton9 =
                                    //
                                    // buttonCreator.createRoundButton(
                                    //                                                        "旋转左",
                                    //                                                        300,
                                    //
                                    // Color.GREEN,
                                    //                                                        200,
                                    //                                                        200,
                                    //                                                        new
                                    // RoundButtonCreator
                                    //
                                    //  .OnButtonTouchListener() {
                                    //
                                    //
                                    // @Override
                                    //
                                    // public void onButtonDown() {
                                    //
                                    //  旋转左();
                                    //                                                            }
                                    //
                                    //
                                    // @Override
                                    //
                                    // public void onButtonUp() {}
                                    //                                                        });
                                    //
                                    //                                    } else {
                                    //
                                    // floatingButton9.setVisibility(View.VISIBLE);
                                    //                                    }
                                    //                                    break;
                                case "旋转左":
                                    // 开关G的开启功能
                                    if (floatingButton9 == null) {
                                        floatingButton9 =
                                                buttonCreator.createRoundButton(
                                                        "旋转左",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {
                                                            private float startX; // 按下时X坐标
                                                            private float startY; // 按下时Y坐标
                                                            private float endX; // 抬起时X坐标
                                                            private float endY; // 抬起时Y坐标
                                                            private boolean isMoved; // 标记是否移动过

                                                            @Override
                                                            public void onButtonDown() {
                                            旋转左();
//                                                                RoundButtonCreator.isMovable = true;
//                                                                isMoved = false; // 重置移动标记
//
//                                                                FrameLayout.LayoutParams
//                                                                        layoutParams =
//                                                                                (FrameLayout
//                                                                                                .LayoutParams)
//                                                                                        floatingButton9
//                                                                                                .getLayoutParams();
//                                                                startX =
//                                                                        layoutParams.leftMargin
//                                                                                + floatingButton9
//                                                                                                .getWidth()
//                                                                                        / 2f; // 按钮中心X
//                                                                startY =
//                                                                        layoutParams.topMargin
//                                                                                + floatingButton9
//                                                                                                .getHeight()
//                                                                                        / 2f; // 按钮中心Y
                                                            }

                                                            @Override
                                                            public void onButtonMove(int x, int y) {
                                                                isMoved = true; // 标记为已移动
                                                                endX =
                                                                        x
                                                                                + floatingButton9
                                                                                                .getWidth()
                                                                                        / 2f; // 按钮中心X;
                                                                endY =
                                                                        y
                                                                                + floatingButton9
                                                                                                .getHeight()
                                                                                        / 2f; // 按钮中心Y;
                                                            }

                                                            @Override
                                                            public void onButtonUp() {
//                                                                RoundButtonCreator.isMovable =
//                                                                        false;
//
//                                                                if (!isMoved) {
//                                                                    // 如果没有移动，确保endX和endY等于startX和startY
//                                                                    endX = startX;
//                                                                    endY = startY;
//                                                                }
//
//                                                                // 计算滑动距离
//                                                                float dx = endX - startX;
//                                                                float dy = endY - startY;
//                                                                double distance =
//                                                                        Math.sqrt(
//                                                                                dx * dx
//                                                                                        + dy
//                                                                                                * dy); // 欧几里得距离
//                                                                double angle =
//                                                                        Math.toDegrees(
//                                                                                Math.atan2(dy, dx));
//                                                                // angle = -angle;
//
//                                                                // 转换为0-360度
//                                                                if (angle < 0) {
//                                                                    angle += 360;
//                                                                }
//
//                                                                if (distance > 50) {
//                                                                    // 如果滑动距离大于50，执行滑动操作
//                                                                    提示.短时提示(
//                                                                            context,
//                                                                            "滑动距离: " + distance
//                                                                                    + "，超过执行滑动"
//                                                                                    + "滑动角度"
//                                                                                    + angle);
//                                                                } else {
//                                                                    // 如果滑动距离小于或等于50，执行点击操作
//                                                                    提示.短时提示(
//                                                                            context,
//                                                                            "滑动距离: " + distance
//                                                                                    + "，不足执行点击");
//                                                                }
//                                                                提示.短时提示(
//                                                                        context,
//                                                                        "当前角度"
//                                                                                + joystickAngle
//                                                                                + "。");
//                                                                boolean isRight;
//                                                                if (Math.abs(angle - joystickAngle)
//                                                                        <= 180) {
//                                                                    isRight = angle > joystickAngle;
//                                                                } else {
//                                                                    isRight = angle < joystickAngle;
//                                                                }
//
//                                                                if (isRight) {
//                                                                    四分测合右();
//                                                                    提示.短时提示(
//                                                                            context,
//                                                                            "滑动角度在 joystickAngle 的右边");
//                                                                } else {
//                                                                    四分测合左();
//                                                                    提示.短时提示(
//                                                                            context,
//                                                                            "滑动角度在 joystickAngle 的左边");
//                                                                }
//
//                                                                // 回到原点
//                                                                FrameLayout.LayoutParams
//                                                                        layoutParams =
//                                                                                (FrameLayout
//                                                                                                .LayoutParams)
//                                                                                        floatingButton9
//                                                                                                .getLayoutParams();
//                                                                layoutParams.leftMargin =
//                                                                        (int)
//                                                                                (startX
//                                                                                        - floatingButton9
//                                                                                                        .getWidth()
//                                                                                                / 2f);
//                                                                layoutParams.topMargin =
//                                                                        (int)
//                                                                                (startY
//                                                                                        - floatingButton9
//                                                                                                        .getHeight()
//                                                                                                / 2f);
//                                                                floatingButton9.setLayoutParams(
//                                                                        layoutParams);
                                                            }
                                                        });
                                    } else {
                                        floatingButton9.setVisibility(View.VISIBLE);
                                    }

                                    break;
                    case "卡点":
                             showCardButton = true; 
                          if (floatingButton15 != null) {
            floatingButton15.setVisibility(View.VISIBLE);
        }
                    floatingButton15.setX(500);
            floatingButton15.setY(500);
                    
    // 是否显示“指定排名”按钮
   
                             break;

                              case "同步":
                           showRankButton = true; 
                          if (floatingButton15 != null) {
            floatingButton13.setVisibility(View.VISIBLE);
        }
                    
                             break;

                                case "旋转右":
                                    // 开关G的开启功能
                                    if (floatingButton10 == null) {
                                        floatingButton10 =
                                                buttonCreator.createRoundButton(
                                                        "旋转右",
                                                        300,
                                                        Color.GREEN,
                                                        200,
                                                        200,
                                                        new RoundButtonCreator
                                                                .OnButtonTouchListener() {

                                                            @Override
                                                            public void onButtonDown() {
                                                                旋转右();
                                                            }

                                                            @Override
                                                            public void onButtonUp() {}
                                                        });

                                    } else {
                                        floatingButton10.setVisibility(View.VISIBLE);
                                    }
                                    break;
                                case "调试按钮位置":
                                    // 开关H的开启功能
                                    RoundButtonCreator.setDebugMode(true);
                                    simpleButtonController.updateButtonVisibility(true);
                                    break;
                                default:
                                    break;
                            }
                        } else {
                            showToast(context, switchName + " 关闭");
                            switch (switchName) {
                                case "切换合球方式":
                                    // 开关A的关闭功能
                                    w1 = true;

                                    break;
                                case "初始化训练营开启":
                                    // 开关A的关闭功能

                                    break;
                                case "吐球":
                                    // 开关B的关闭功能
                                    if (floatingButton1 != null) {
                                        floatingButton1.setVisibility(View.GONE);
                                    }
                                    break;
                                case "4分":
                                    // 开关B的关闭功能
                                    if (floatingButton11 != null) {
                                        floatingButton11.setVisibility(View.GONE);
                                    }
                                    break;
                                case "冲球16分":
                                    // 开关B的关闭功能
                                    if (floatingButton12 != null) {
                                        floatingButton12.setVisibility(View.GONE);
                                    }
                                    break;
                                case "分身":
                                    // 开关B的关闭功能
                                    if (floatingButton13 != null) {
                                        floatingButton13.setVisibility(View.GONE);
                                    }
                                    break;
                                case "内存卡点":
                                    // 开关B的关闭功能
                                    if (floatingButton14 != null) {
                                        floatingButton14.setVisibility(View.GONE);
                                    }
                                    break;
                                case "三角":
                                    // 开关C的关闭功能
                                    if (floatingButton2 != null) {
                                        floatingButton2.setVisibility(View.GONE);
                                    }
                                    break;
                                case "蛇手左":
                                    // 开关D的关闭功能
                                    if (floatingButton3 != null) {
                                        floatingButton3.setVisibility(View.GONE);
                                    }
                                    break;
                                case "蛇手右":
                                    // 开关E的关闭功能
                                    if (floatingButton4 != null) {
                                        floatingButton4.setVisibility(View.GONE);
                                    }
                                    break;
                                case "四分测合左":
                                    // 开关F的关闭功能
                                    if (floatingButton5 != null) {
                                        floatingButton5.setVisibility(View.GONE);
                                    }
                                    break;
                                case "四分测合右":
                                    // 开关G的关闭功能
                                    if (floatingButton6 != null) {
                                        floatingButton6.setVisibility(View.GONE);
                                    }
                                    break;
                                case "后仰左":
                                    // 开关G的关闭功能
                                    if (floatingButton7 != null) {
                                        floatingButton7.setVisibility(View.GONE);
                                    }
                                    break;
                                case "后仰右":
                                    // 开关G的关闭功能
                                    if (floatingButton8 != null) {
                                        floatingButton8.setVisibility(View.GONE);
                                    }
                                    break;
                                case "旋转左":
                                    // 开关G的关闭功能
                                    if (floatingButton9 != null) {
                                        floatingButton9.setVisibility(View.GONE);
                                    }
                                    break;
                                case "旋转右":
                                    // 开关G的关闭功能
                                    if (floatingButton10 != null) {
                                        floatingButton10.setVisibility(View.GONE);
                                    }
                                    break;
                                case "黑屏卡点":
                                    // 开关G的关闭功能
                                    if (floatingButton15 != null) {
                                        floatingButton15.setVisibility(View.GONE);
                                    }
                                    break;
                    case "卡点":
                             showCardButton = true;
                     if (floatingButton15 != null) {
            floatingButton15.setVisibility(View.GONE);
        }
                             break;

                              case "同步":
                             showRankButton = true;
                    if (floatingButton13 != null) {
            floatingButton13.setVisibility(View.GONE);
        }
                             break;
                                case "调试按钮位置":
                                    // 开关H的关闭功能
                                    RoundButtonCreator.setDebugMode(false);
                                    simpleButtonController.updateButtonVisibility(false);
                                    break;
                                default:
                                    break;
                            }
                        }
                    });

        switchContainer.addView(switchButton);
    }

    scrollView.addView(switchContainer);
    page2Layout.addView(scrollView);

    return page2Layout;
}



    private LinearLayout createPage3Layout(Context context) {
    // 分页3
    LinearLayout page3Layout = new LinearLayout(context);
    page3Layout.setOrientation(VERTICAL);

    ScrollView scrollView = new ScrollView(context);
    scrollView.setLayoutParams(new LayoutParams(
            LayoutParams.MATCH_PARENT,
            LayoutParams.MATCH_PARENT
    ));
    LinearLayout.LayoutParams spacingParams = new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, dpToPx(8)); // 8dp间隔

    GradientDrawable scrollBackground = new GradientDrawable();
    scrollBackground.setColor(Color.parseColor("#2D2A4A"));
    scrollBackground.setCornerRadius(16); // 圆角背景
    scrollView.setBackground(scrollBackground);

    LinearLayout mainLayout = new LinearLayout(context);
    mainLayout.setOrientation(VERTICAL);
    mainLayout.setLayoutParams(new LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
    ));
    int sidePadding = dpToPx(16); // 设置左右边距
    mainLayout.setPadding(sidePadding, 0, sidePadding, 0);

    // 吐球分身设置
    mainLayout.addView(createCollapsibleSection(context, "分身吐球卡点设置", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);
                    
    addSeekBarWithEditText(context, layout, "分辨率x", parameters.分辨率x, 0, 4000, value -> parameters.分辨率x = value);
    addSeekBarWithEditText(context, layout, "分辨率y", parameters.分辨率y, 0, 2000, value -> parameters.分辨率y = value);
   addFloatSeekBarWithEditText(context, layout, "比例", parameters.比例, 0, 2, value -> parameters.比例 = value);
    addSeekBarWithEditText(context, layout, "吐球1秒次数", parameters.吐球1秒次数, 00, 1000, value -> parameters.吐球1秒次数 = value);
    addSeekBarWithEditText(context, layout, "四分延时", parameters.四分延时, 0, 100, value -> parameters.四分延时 = value);
    addSeekBarWithEditText(context, layout, "四分后延时", parameters.四分后延时, 0, 1000, value -> parameters.四分后延时 = value);
    addSeekBarWithEditText(context, layout, "四分后分身间隔", parameters.四分后分身间隔, 0, 100, value -> parameters.四分后分身间隔 = value);
    addSeekBarWithEditText(context, layout, "冲球指定次数", parameters.冲球指定次数, 0, 100, value -> parameters.冲球指定次数 = value);
    addSeekBarWithEditText(context, layout, "冲球分身间隔", parameters.冲球分身间隔, 0, 100, value -> parameters.冲球分身间隔 = value);

    addSeekBarWithEditText(context, layout, "长按分身延时", parameters.长按分身延时, 0, 1000, value -> parameters.长按分身延时 = value);
    addSeekBarWithEditText(context, layout, "长按分身间隔", parameters.长按分身间隔, 0, 100, value -> parameters.长按分身间隔 = value);
                    
  //  addSeekBarWithEditText(context, layout, "卡点过滤", parameters.卡点过滤, 0, 10, value -> parameters.卡点过滤 = value);
    addSeekBarWithEditText(context, layout, "卡点分身前摇", parameters.卡点前摇, 0, 1000, value -> parameters.卡点前摇 = value);
    addSeekBarWithEditText(context, layout, "卡点分身次数", parameters.卡点分身次数, 0, 100, value -> parameters.卡点分身次数 = value);
    addSeekBarWithEditText(context, layout, "卡点分身间隔", parameters.卡点分身间隔, 0, 100, value -> parameters.卡点分身间隔 = value);
    addSeekBarWithEditText(context, layout, "同步分身前摇", parameters.同步前摇, 0, 1000, value -> parameters.同步前摇 = value);
    addSeekBarWithEditText(context, layout, "同步分身次数", parameters.同步分身次数, 0, 100, value -> parameters.同步分身次数 = value);
    addSeekBarWithEditText(context, layout, "同步分身间隔", parameters.同步分身间隔, 0, 100, value -> parameters.同步分身间隔 = value);





    return layout;
}));

mainLayout.addView(new View(context), spacingParams);

// 三角参数
mainLayout.addView(createCollapsibleSection(context, "三角参数", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);

    addSeekBarWithEditText(context, layout, "三角1滑动角度", (int) parameters.三角1滑动角度, -180, 180, value -> parameters.三角1滑动角度 = value);
    addSeekBarWithEditText(context, layout, "三角1滑动长度", parameters.三角1滑动长度, 0, 1000, value -> parameters.三角1滑动长度 = value);
    addSeekBarWithEditText(context, layout, "三角1滑动时长", parameters.三角1滑动时长, 0, 500, value -> parameters.三角1滑动时长 = value);
    addSeekBarWithEditText(context, layout, "三角1点击延时", parameters.三角1点击延时, 0, 500, value -> parameters.三角1点击延时 = value);
    addSeekBarWithEditText(context, layout, "三角2滑动延时", parameters.三角2滑动延时, 0, 500, value -> parameters.三角2滑动延时 = value);

    addSeekBarWithEditText(context, layout, "三角2滑动角度", (int) parameters.三角2滑动角度, -180, 180, value -> parameters.三角2滑动角度 = value);
    addSeekBarWithEditText(context, layout, "三角2滑动长度", parameters.三角2滑动长度, 0, 1000, value -> parameters.三角2滑动长度 = value);
    addSeekBarWithEditText(context, layout, "三角2滑动时长", parameters.三角2滑动时长, 0, 500, value -> parameters.三角2滑动时长 = value);
    addSeekBarWithEditText(context, layout, "三角2点击延时", parameters.三角2点击延时, 0, 500, value -> parameters.三角2点击延时 = value);
    addSeekBarWithEditText(context, layout, "三角3滑动延时", parameters.三角3滑动延时, 0, 500, value -> parameters.三角3滑动延时 = value);

    addSeekBarWithEditText(context, layout, "三角3滑动角度", (int) parameters.三角3滑动角度, -180, 180, value -> parameters.三角3滑动角度 = value);
    addSeekBarWithEditText(context, layout, "三角3滑动长度", parameters.三角3滑动长度, 0, 1000, value -> parameters.三角3滑动长度 = value);
    addSeekBarWithEditText(context, layout, "三角3滑动时长", parameters.三角3滑动时长, 0, 500, value -> parameters.三角3滑动时长 = value);

    addSeekBarWithEditText(context, layout, "三角分身次数", parameters.三角分身次数, 0, 100, value -> parameters.三角分身次数 = value);
    addSeekBarWithEditText(context, layout, "三角分身延时", parameters.三角分身延时, 0, 500, value -> parameters.三角分身延时 = value);

    return layout;
}));

mainLayout.addView(new View(context), spacingParams);

// 蛇手左参数
mainLayout.addView(createCollapsibleSection(context, "蛇手左", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);

    addSeekBarWithEditText(context, layout, "蛇手左滑动1角度", (int) parameters.蛇手左滑动1角度, -180, 180, value -> parameters.蛇手左滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动1长度", parameters.蛇手左滑动1长度, 0, 1000, value -> parameters.蛇手左滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动1时长", parameters.蛇手左滑动1时长, 0, 500, value -> parameters.蛇手左滑动1时长 = value);
    addSeekBarWithEditText(context, layout, "蛇手左分身延时1", parameters.蛇手左分身延时1, 0, 500, value -> parameters.蛇手左分身延时1 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动延时2", parameters.蛇手左滑动延时2, 0, 500, value -> parameters.蛇手左滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "蛇手左滑动2角度", (int) parameters.蛇手左滑动2角度, -180, 180, value -> parameters.蛇手左滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动2长度", parameters.蛇手左滑动2长度, 0, 1000, value -> parameters.蛇手左滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动2时长", parameters.蛇手左滑动2时长, 0, 500, value -> parameters.蛇手左滑动2时长 = value);
    addSeekBarWithEditText(context, layout, "蛇手左分身延时2", parameters.蛇手左分身延时2, 0, 500, value -> parameters.蛇手左分身延时2 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动延时3", parameters.蛇手左滑动延时3, 0, 500, value -> parameters.蛇手左滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "蛇手左滑动3角度", (int) parameters.蛇手左滑动3角度, -180, 180, value -> parameters.蛇手左滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动3长度", parameters.蛇手左滑动3长度, 0, 1000, value -> parameters.蛇手左滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手左滑动3时长", parameters.蛇手左滑动3时长, 0, 500, value -> parameters.蛇手左滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "蛇手左分身点击次数", parameters.蛇手左分身点击次数, 0, 100, value -> parameters.蛇手左分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "蛇手左分身点击延时", parameters.蛇手左分身点击延时, 0, 500, value -> parameters.蛇手左分身点击延时 = value);

    return layout;
}));

mainLayout.addView(new View(context), spacingParams);

// 蛇手右参数
mainLayout.addView(createCollapsibleSection(context, "蛇手右", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);

    addSeekBarWithEditText(context, layout, "蛇手右滑动1角度", (int) parameters.蛇手右滑动1角度, -180, 180, value -> parameters.蛇手右滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动1长度", parameters.蛇手右滑动1长度, 0, 1000, value -> parameters.蛇手右滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动1时长", parameters.蛇手右滑动1时长, 0, 500, value -> parameters.蛇手右滑动1时长 = value);
    addSeekBarWithEditText(context, layout, "蛇手右分身延时1", parameters.蛇手右分身延时1, 0, 500, value -> parameters.蛇手右分身延时1 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动延时2", parameters.蛇手右滑动延时2, 0, 500, value -> parameters.蛇手右滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "蛇手右滑动2角度", (int) parameters.蛇手右滑动2角度, -180, 180, value -> parameters.蛇手右滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动2长度", parameters.蛇手右滑动2长度, 0, 1000, value -> parameters.蛇手右滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动2时长", parameters.蛇手右滑动2时长, 0, 500, value -> parameters.蛇手右滑动2时长 = value);
    addSeekBarWithEditText(context, layout, "蛇手右分身延时2", parameters.蛇手右分身延时2, 0, 500, value -> parameters.蛇手右分身延时2 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动延时3", parameters.蛇手右滑动延时3, 0, 500, value -> parameters.蛇手右滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "蛇手右滑动3角度", (int) parameters.蛇手右滑动3角度, -180, 180, value -> parameters.蛇手右滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动3长度", parameters.蛇手右滑动3长度, 0, 1000, value -> parameters.蛇手右滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "蛇手右滑动3时长", parameters.蛇手右滑动3时长, 0, 500, value -> parameters.蛇手右滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "蛇手右分身点击次数", parameters.蛇手右分身点击次数, 0, 100, value -> parameters.蛇手右分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "蛇手右分身点击延时", parameters.蛇手右分身点击延时, 0, 500, value -> parameters.蛇手右分身点击延时 = value);

    return layout;
}));

        
    mainLayout.addView(new View(context), spacingParams);

    // 四分测合左
    mainLayout.addView(createCollapsibleSection(context, "四分测合左", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);
    
    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.四分测合左1角度, -180, 180, value -> parameters.四分测合左1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.四分测合左1滑动长度, 0, 1000, value -> parameters.四分测合左1滑动长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.四分测合左1滑动时长, 0, 500, value -> parameters.四分测合左1滑动时长 = value);
                                    
    addSeekBarWithEditText(context, layout, "4分前延时", parameters.四分测合左2分前延时, 0, 500, value -> parameters.四分测合左2分前延时 = value);
    addSeekBarWithEditText(context, layout, "4分延时", parameters.四分测合左2分身延时, 0, 500, value -> parameters.四分测合左2分身延时 = value);
    addSeekBarWithEditText(context, layout, "4分后延时", parameters.四分测合左2分后延时, 0, 500, value -> parameters.四分测合左2分后延时 = value);
    
    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.四分测合左2角度, -180, 180, value -> parameters.四分测合左2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.四分测合左2滑动长度, 0, 1000, value -> parameters.四分测合左2滑动长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.四分测合左2滑动时长, 0, 500, value -> parameters.四分测合左2滑动时长 = value);

    addSeekBarWithEditText(context, layout, "点击次数", parameters.四分测合左点击分身次数, 0, 100, value -> parameters.四分测合左点击分身次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.四分测合左点击延时, 0, 500, value -> parameters.四分测合左点击延时 = value);

    return layout;
}));

mainLayout.addView(new View(context), spacingParams);

// 四分测合右
mainLayout.addView(createCollapsibleSection(context, "四分测合右", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);
    
    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.四分测合右1角度, -180, 180, value -> parameters.四分测合右1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.四分测合右1滑动长度, 0, 1000, value -> parameters.四分测合右1滑动长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.四分测合右1滑动时长, 0, 500, value -> parameters.四分测合右1滑动时长 = value);
                                    
    addSeekBarWithEditText(context, layout, "4分前延时", parameters.四分测合右2分前延时, 0, 500, value -> parameters.四分测合右2分前延时 = value);
    addSeekBarWithEditText(context, layout, "4分延时", parameters.四分测合右2分延时, 0, 500, value -> parameters.四分测合右2分延时 = value);
    addSeekBarWithEditText(context, layout, "4分后延时", parameters.四分测合右2分后延时, 0, 500, value -> parameters.四分测合右2分后延时 = value);
    
    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.四分测合右2角度, -180, 180, value -> parameters.四分测合右2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.四分测合右2滑动长度, 0, 1000, value -> parameters.四分测合右2滑动长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.四分测合右2滑动时长, 0, 500, value -> parameters.四分测合右2滑动时长 = value);

    addSeekBarWithEditText(context, layout, "点击次数", parameters.四分测合右点击分身次数, 0, 100, value -> parameters.四分测合右点击分身次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.四分测合右点击延时, 0, 500, value -> parameters.四分测合右点击延时 = value);

    return layout;
}));
        
        mainLayout.addView(new View(context), spacingParams);

// 后仰左
mainLayout.addView(createCollapsibleSection(context, "后仰左", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);
    
    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.后仰左滑动1角度, -180, 180, value -> parameters.后仰左滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.后仰左滑动1长度, 0, 1000, value -> parameters.后仰左滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.后仰左滑动1时长, 0, 500, value -> parameters.后仰左滑动1时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时1", parameters.后仰左分身延时1, 0, 500, value -> parameters.后仰左分身延时1 = value);
    addSeekBarWithEditText(context, layout, "滑动延时2", parameters.后仰左滑动延时2, 0, 500, value -> parameters.后仰左滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.后仰左滑动2角度, -180, 180, value -> parameters.后仰左滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.后仰左滑动2长度, 0, 1000, value -> parameters.后仰左滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.后仰左滑动2时长, 0, 500, value -> parameters.后仰左滑动2时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时2", parameters.后仰左分身延时2, 0, 500, value -> parameters.后仰左分身延时2 = value);
    addSeekBarWithEditText(context, layout, "滑动延时3", parameters.后仰左滑动延时3, 0, 500, value -> parameters.后仰左滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "滑动3角度", (int) parameters.后仰左滑动3角度, -180, 180, value -> parameters.后仰左滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "滑动3长度", parameters.后仰左滑动3长度, 0, 1000, value -> parameters.后仰左滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "滑动3时长", parameters.后仰左滑动3时长, 0, 500, value -> parameters.后仰左滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "分身点击次数", parameters.后仰左分身点击次数, 0, 100, value -> parameters.后仰左分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.后仰左分身点击延时, 0, 500, value -> parameters.后仰左分身点击延时 = value);

    return layout;
}));
        
        mainLayout.addView(new View(context), spacingParams);

// 后仰右
mainLayout.addView(createCollapsibleSection(context, "后仰右", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);
    
    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.后仰右滑动1角度, -180, 180, value -> parameters.后仰右滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.后仰右滑动1长度, 0, 1000, value -> parameters.后仰右滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.后仰右滑动1时长, 0, 500, value -> parameters.后仰右滑动1时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时1", parameters.后仰右分身延时1, 0, 500, value -> parameters.后仰右分身延时1 = value);
    addSeekBarWithEditText(context, layout, "滑动延时2", parameters.后仰右滑动延时2, 0, 500, value -> parameters.后仰右滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.后仰右滑动2角度, -180, 180, value -> parameters.后仰右滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.后仰右滑动2长度, 0, 1000, value -> parameters.后仰右滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.后仰右滑动2时长, 0, 500, value -> parameters.后仰右滑动2时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时2", parameters.后仰右分身延时2, 0, 500, value -> parameters.后仰右分身延时2 = value);
    addSeekBarWithEditText(context, layout, "滑动延时3", parameters.后仰右滑动延时3, 0, 500, value -> parameters.后仰右滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "滑动3角度", (int) parameters.后仰右滑动3角度, -180, 180, value -> parameters.后仰右滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "滑动3长度", parameters.后仰右滑动3长度, 0, 1000, value -> parameters.后仰右滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "滑动3时长", parameters.后仰右滑动3时长, 0, 500, value -> parameters.后仰右滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "分身点击次数", parameters.后仰右分身点击次数, 0, 100, value -> parameters.后仰右分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.后仰右分身点击延时, 0, 500, value -> parameters.后仰右分身点击延时 = value);

    return layout;
}));
        mainLayout.addView(new View(context), spacingParams);
        mainLayout.addView(createCollapsibleSection(context, "旋转左", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);

    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.旋转左滑动1角度, -180, 180, value -> parameters.旋转左滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.旋转左滑动1长度, 0, 1000, value -> parameters.旋转左滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.旋转左滑动1时长, 0, 500, value -> parameters.旋转左滑动1时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时1", parameters.旋转左分身延时1, 0, 500, value -> parameters.旋转左分身延时1 = value);
    addSeekBarWithEditText(context, layout, "滑动延时2", parameters.旋转左滑动延时2, 0, 500, value -> parameters.旋转左滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.旋转左滑动2角度, -180, 180, value -> parameters.旋转左滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.旋转左滑动2长度, 0, 1000, value -> parameters.旋转左滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.旋转左滑动2时长, 0, 500, value -> parameters.旋转左滑动2时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时2", parameters.旋转左分身延时2, 0, 500, value -> parameters.旋转左分身延时2 = value);
    addSeekBarWithEditText(context, layout, "滑动延时3", parameters.旋转左滑动延时3, 0, 500, value -> parameters.旋转左滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "滑动3角度", (int) parameters.旋转左滑动3角度, -180, 180, value -> parameters.旋转左滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "滑动3长度", parameters.旋转左滑动3长度, 0, 1000, value -> parameters.旋转左滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "滑动3时长", parameters.旋转左滑动3时长, 0, 500, value -> parameters.旋转左滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时3", parameters.旋转左分身延时3, 0, 500, value -> parameters.旋转左分身延时3 = value);
    addSeekBarWithEditText(context, layout, "滑动延时4", parameters.旋转左滑动延时4, 0, 500, value -> parameters.旋转左滑动延时4 = value);

    addSeekBarWithEditText(context, layout, "滑动4角度", (int) parameters.旋转左滑动4角度, -180, 180, value -> parameters.旋转左滑动4角度 = value);
    addSeekBarWithEditText(context, layout, "滑动4长度", parameters.旋转左滑动4长度, 0, 1000, value -> parameters.旋转左滑动4长度 = value);
    addSeekBarWithEditText(context, layout, "滑动4时长", parameters.旋转左滑动4时长, 0, 500, value -> parameters.旋转左滑动4时长 = value);

    addSeekBarWithEditText(context, layout, "摇杆点击延时4", parameters.旋转左摇杆点击延时4, 0, 500, value -> parameters.旋转左摇杆点击延时4 = value);
    addSeekBarWithEditText(context, layout, "分身连击延时", parameters.旋转左分身连击延时, 0, 500, value -> parameters.旋转左分身连击延时 = value);

    addSeekBarWithEditText(context, layout, "分身点击次数", parameters.旋转左分身点击次数, 0, 100, value -> parameters.旋转左分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.旋转左分身点击延时, 0, 500, value -> parameters.旋转左分身点击延时 = value);

    return layout;
}));

        mainLayout.addView(new View(context), spacingParams);

mainLayout.addView(createCollapsibleSection(context, "旋转右", () -> {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(VERTICAL);

    addSeekBarWithEditText(context, layout, "滑动1角度", (int) parameters.旋转右滑动1角度, -180, 180, value -> parameters.旋转右滑动1角度 = value);
    addSeekBarWithEditText(context, layout, "滑动1长度", parameters.旋转右滑动1长度, 0, 1000, value -> parameters.旋转右滑动1长度 = value);
    addSeekBarWithEditText(context, layout, "滑动1时长", parameters.旋转右滑动1时长, 0, 500, value -> parameters.旋转右滑动1时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时1", parameters.旋转右分身延时1, 0, 500, value -> parameters.旋转右分身延时1 = value);
    addSeekBarWithEditText(context, layout, "滑动延时2", parameters.旋转右滑动延时2, 0, 500, value -> parameters.旋转右滑动延时2 = value);

    addSeekBarWithEditText(context, layout, "滑动2角度", (int) parameters.旋转右滑动2角度, -180, 180, value -> parameters.旋转右滑动2角度 = value);
    addSeekBarWithEditText(context, layout, "滑动2长度", parameters.旋转右滑动2长度, 0, 1000, value -> parameters.旋转右滑动2长度 = value);
    addSeekBarWithEditText(context, layout, "滑动2时长", parameters.旋转右滑动2时长, 0, 500, value -> parameters.旋转右滑动2时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时2", parameters.旋转右分身延时2, 0, 500, value -> parameters.旋转右分身延时2 = value);
    addSeekBarWithEditText(context, layout, "滑动延时3", parameters.旋转右滑动延时3, 0, 500, value -> parameters.旋转右滑动延时3 = value);

    addSeekBarWithEditText(context, layout, "滑动3角度", (int) parameters.旋转右滑动3角度, -180, 180, value -> parameters.旋转右滑动3角度 = value);
    addSeekBarWithEditText(context, layout, "滑动3长度", parameters.旋转右滑动3长度, 0, 1000, value -> parameters.旋转右滑动3长度 = value);
    addSeekBarWithEditText(context, layout, "滑动3时长", parameters.旋转右滑动3时长, 0, 500, value -> parameters.旋转右滑动3时长 = value);

    addSeekBarWithEditText(context, layout, "分身延时3", parameters.旋转右分身延时3, 0, 500, value -> parameters.旋转右分身延时3 = value);
    addSeekBarWithEditText(context, layout, "滑动延时4", parameters.旋转右滑动延时4, 0, 500, value -> parameters.旋转右滑动延时4 = value);

    addSeekBarWithEditText(context, layout, "滑动4角度", (int) parameters.旋转右滑动4角度, -180, 180, value -> parameters.旋转右滑动4角度 = value);
    addSeekBarWithEditText(context, layout, "滑动4长度", parameters.旋转右滑动4长度, 0, 1000, value -> parameters.旋转右滑动4长度 = value);
    addSeekBarWithEditText(context, layout, "滑动4时长", parameters.旋转右滑动4时长, 0, 500, value -> parameters.旋转右滑动4时长 = value);

    addSeekBarWithEditText(context, layout, "摇杆点击延时4", parameters.旋转右摇杆点击延时4, 0, 500, value -> parameters.旋转右摇杆点击延时4 = value);
    addSeekBarWithEditText(context, layout, "分身连击延时", parameters.旋转右分身连击延时, 0, 500, value -> parameters.旋转右分身连击延时 = value);

    addSeekBarWithEditText(context, layout, "分身点击次数", parameters.旋转右分身点击次数, 0, 100, value -> parameters.旋转右分身点击次数 = value);
    addSeekBarWithEditText(context, layout, "点击延时", parameters.旋转右分身点击延时, 0, 500, value -> parameters.旋转右分身点击延时 = value);

    return layout;
}));



    
    scrollView.addView(mainLayout);
    page3Layout.addView(scrollView);

    return page3Layout;
}
// 可折叠区域的创建方法
private LinearLayout createCollapsibleSection(Context context, String title, CollapsibleContentProvider contentProvider) {
    LinearLayout sectionLayout = new LinearLayout(context);
    sectionLayout.setOrientation(VERTICAL);

    // 设置折叠标题的样式
    TextView titleView = new TextView(context);
    titleView.setText(title);
    titleView.setTextSize(12); // 使用相同的小字体大小
    titleView.setTextColor(Color.parseColor("#B9A6FF")); // 字体颜色
    titleView.setGravity(Gravity.CENTER_VERTICAL);
    titleView.setPadding(16, 16, 16, 16);

    // 设置圆角背景
    GradientDrawable background = new GradientDrawable();
    background.setColor(Color.parseColor("#3A355A")); // 背景色契合主窗体
    background.setCornerRadius(16); // 圆角背景
    titleView.setBackground(background);

    // 创建内容容器并设置为折叠状态
    LinearLayout contentLayout = contentProvider.provideContent();
    contentLayout.setVisibility(GONE); // 初始折叠
    sectionLayout.addView(titleView);
    sectionLayout.addView(contentLayout);

    // 设置点击折叠/展开逻辑
    titleView.setOnClickListener(v -> {
        if (contentLayout.getVisibility() == VISIBLE) {
            contentLayout.setVisibility(GONE);
        } else {
            contentLayout.setVisibility(VISIBLE);
        }
    });

    return sectionLayout;
}

    //分页布局4
    private LinearLayout createPage4Layout(Context context) {
    // 最外层布局（垂直方向）
    LinearLayout page4Layout = new LinearLayout(context);
    page4Layout.setOrientation(LinearLayout.VERTICAL);
    int margin = dpToPx(16);
    LayoutParams page4LayoutParams = new LayoutParams(
            LayoutParams.MATCH_PARENT,
            LayoutParams.MATCH_PARENT
    );
    page4LayoutParams.setMargins(margin, margin, margin, margin);
    page4Layout.setLayoutParams(page4LayoutParams);

    // ------------------ 标题文字 ------------------
    TextView textView = new TextView(context);
    textView.setText("在此处设置指定排名ID并保存到文件。");
    textView.setTextSize(16);
    textView.setTextColor(Color.parseColor("#B9A6FF")); // 紫色
    page4Layout.addView(textView);

    // ------------------ 横向容器: 左侧 EditText，右侧按钮 ------------------
    LinearLayout inputRowLayout = new LinearLayout(context);
    inputRowLayout.setOrientation(LinearLayout.HORIZONTAL);
    inputRowLayout.setLayoutParams(new LayoutParams(
            LayoutParams.MATCH_PARENT,
            LayoutParams.WRAP_CONTENT
    ));
    inputRowLayout.setPadding(0, dpToPx(8), 0, dpToPx(8));
    page4Layout.addView(inputRowLayout);

    // ---- EditText ----
    EditText editTextRankId = new EditText(context);
    editTextRankId.setHint("请输入新的排名ID");
    editTextRankId.setInputType(InputType.TYPE_CLASS_NUMBER);
    editTextRankId.setTextSize(16);
    editTextRankId.setTextColor(Color.parseColor("#B9A6FF"));       // 字体颜色
    editTextRankId.setHintTextColor(Color.parseColor("#50B9A6FF")); // Hint 半透明紫
    editTextRankId.setHighlightColor(Color.parseColor("#50B9A6FF")); // 选中文字高亮颜色

    // 去掉原生的下划线背景，这样我们可以自定义“横线”或边框
    editTextRankId.setBackground(null);

    // 给 EditText 添加一个底部横条。方法之一：用一个 View 做分割线
    // 这里演示：包一层容器，在容器底部画线
    LinearLayout editTextContainer = new LinearLayout(context);
    editTextContainer.setOrientation(LinearLayout.VERTICAL);
    editTextContainer.setLayoutParams(new LinearLayout.LayoutParams(
            0, // 宽度先占 0
            LayoutParams.WRAP_CONTENT,
            1f // weight = 1，让它占满剩余空间
    ));

    // 把 EditText 加到这个容器里
    editTextContainer.addView(editTextRankId);

    // 再加一个 2px 高度的横条 View
    View underlineView = new View(context);
    underlineView.setLayoutParams(new LayoutParams(
            LayoutParams.MATCH_PARENT,
            dpToPx(2)
    ));
    // 先设置默认颜色（不聚焦时）
    underlineView.setBackgroundColor(Color.parseColor("#50B9A6FF"));
    editTextContainer.addView(underlineView);

    // 如果需要在 EditText 聚焦时变色，可以监听焦点变化
    editTextRankId.setOnFocusChangeListener((v, hasFocus) -> {
        if (hasFocus) {
            // 聚焦时，让横线更鲜明
            underlineView.setBackgroundColor(Color.parseColor("#B9A6FF"));
        } else {
            // 失焦时，淡下去
            underlineView.setBackgroundColor(Color.parseColor("#50B9A6FF"));
        }
    });

    // 将容器（含 EditText+底部横线）加到行布局
    inputRowLayout.addView(editTextContainer);

    // 预先显示当前在主类中的指定排名ID
    editTextRankId.setText(String.valueOf(specifiedRankId));

    // ---- 按钮 ----
    Button saveButton = new Button(context);
    saveButton.setText("保存并更新排名ID");
    saveButton.setTextSize(16);
    saveButton.setTextColor(Color.parseColor("#B9A6FF")); // 按钮文字颜色

    // 自定义按钮背景 - 圆角描边
    GradientDrawable buttonBg = new GradientDrawable();
    buttonBg.setCornerRadius(dpToPx(8));                 // 圆角
    buttonBg.setColor(Color.parseColor("#33000000"));    // 半透明深色(示例) 或者 "#1AFFFFFF"等
    // 外边描边为紫色
    buttonBg.setStroke(dpToPx(1), Color.parseColor("#B9A6FF"));
    saveButton.setBackground(buttonBg);

    // 设置按钮在行布局里包裹大小，并留点左边距
    LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(
            LayoutParams.WRAP_CONTENT,
            LayoutParams.WRAP_CONTENT
    );
    buttonParams.leftMargin = dpToPx(16);  // 按钮与输入框之间的距离
    saveButton.setLayoutParams(buttonParams);

    // 点击事件
    saveButton.setOnClickListener(v -> {
        String inputText = editTextRankId.getText().toString().trim();
        if (TextUtils.isEmpty(inputText)) {
            Toast.makeText(context, "输入不能为空", Toast.LENGTH_SHORT).show();
            return;
        }
        try {
            int newRankId = Integer.parseInt(inputText);
            specifiedRankId = newRankId;

            boolean 写入成功 = 文件读写.写入(
                    context,
                    "RankId.txt",
                    newRankId,
                    false,
                    false
            );
            if (写入成功) {
                Toast.makeText(context, "保存成功，新的排名ID=" + newRankId, Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "保存失败，请检查权限或系统版本", Toast.LENGTH_SHORT).show();
            }
        } catch (NumberFormatException e) {
            Toast.makeText(context, "输入格式错误，请输入数字", Toast.LENGTH_SHORT).show();
            e.printStackTrace();
        }
    });

    // 加入行布局
    inputRowLayout.addView(saveButton);

    return page4Layout;
}




    private void addSeekBarWithEditText(Context context, LinearLayout layout, String labelText, int initialValue, int min, int max, SeekBar.OnSeekBarChangeListener listener) {
        LinearLayout seekBarLayout = new LinearLayout(context);
        seekBarLayout.setOrientation(HORIZONTAL);
        seekBarLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, dpToPx(40)));
        seekBarLayout.setPadding(dpToPx(4), dpToPx(6), dpToPx(4), dpToPx(6));

        TextView label = new TextView(context);
        label.setText(labelText);
        label.setTextColor(Color.WHITE);
        label.setLayoutParams(new LayoutParams(0, LayoutParams.WRAP_CONTENT, 1));
        seekBarLayout.addView(label);

        SeekBar seekBar = new SeekBar(context);
        seekBar.setMax(max - min);
        seekBar.setProgress(initialValue - min);
        seekBar.setLayoutParams(new LayoutParams(dpToPx(160), LayoutParams.WRAP_CONTENT));
        seekBar.setOnSeekBarChangeListener(listener);
        seekBarLayout.addView(seekBar);

        EditText valueInput = new EditText(context);
        valueInput.setText(String.valueOf(initialValue));
        valueInput.setTextColor(Color.WHITE);
        valueInput.setBackgroundColor(Color.TRANSPARENT);
        valueInput.setLayoutParams(new LayoutParams(dpToPx(50), LayoutParams.WRAP_CONTENT));
        valueInput.setGravity(Gravity.CENTER);
        valueInput.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
                try {
                    int value = Integer.parseInt(charSequence.toString());
                    seekBar.setProgress(value - min);
                } catch (NumberFormatException e) {}
            }

            @Override
            public void afterTextChanged(Editable editable) {}
        });

        seekBarLayout.addView(valueInput);
        layout.addView(seekBarLayout);
    }

    private LinearLayout createCollapsibleSection(Context context, String title, CollapsibleSectionContentProvider contentProvider) {
        LinearLayout sectionLayout = new LinearLayout(context);
        sectionLayout.setOrientation(VERTICAL);
        sectionLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));

        TextView sectionTitle = new TextView(context);
        sectionTitle.setText(title);
        sectionTitle.setTextColor(Color.WHITE);
        sectionTitle.setTextSize(16);
        sectionTitle.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, dpToPx(40)));
        sectionLayout.addView(sectionTitle);

        sectionLayout.addView(contentProvider.provideContent());
        return sectionLayout;
    }
    
    //整数
    private void addSeekBarWithEditText(Context context, LinearLayout parent, String label, int initialValue, int min, int max, ValueChangeListener listener) {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(LinearLayout.HORIZONTAL);
    layout.setLayoutParams(new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
    ));
    layout.setPadding(8, 4, 8, 4);

    TextView labelView = new TextView(context);
    labelView.setText(label);
    labelView.setTextSize(10); // 小字体
    labelView.setTextColor(Color.parseColor("#B9A6FF"));
    labelView.setGravity(Gravity.CENTER_VERTICAL);
    labelView.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 1.2f));
    layout.addView(labelView);

    // 设置 SeekBar 居中
    SeekBar seekBar = new SeekBar(context);
    LinearLayout.LayoutParams seekBarParams = new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 2f);
    seekBarParams.setMargins(0, 20, 0, 0); // 调整上下边距以居中
    seekBar.setLayoutParams(seekBarParams);
    seekBar.setMax(max - min);
    seekBar.setProgress(initialValue - min);
    seekBar.getThumb().setColorFilter(Color.parseColor("#6F5A9A"), android.graphics.PorterDuff.Mode.SRC_IN);
    seekBar.getProgressDrawable().setColorFilter(Color.parseColor("#A390E4"), android.graphics.PorterDuff.Mode.SRC_IN);
    layout.addView(seekBar);

    // 配置带圆角背景的输入框
    EditText valueEditText = new EditText(context);
    valueEditText.setText(String.valueOf(initialValue));
    valueEditText.setTextSize(10);
    valueEditText.setTextColor(Color.parseColor("#B9A6FF"));
    valueEditText.setGravity(Gravity.CENTER);
    
    // 设置输入框圆角背景
    GradientDrawable editTextBackground = new GradientDrawable();
    editTextBackground.setColor(Color.parseColor("#3A355A")); // 背景颜色
    editTextBackground.setCornerRadius(16); // 圆角半径
    valueEditText.setBackground(editTextBackground);

    valueEditText.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 0.8f));
    layout.addView(valueEditText);

    // 滑动条和输入框的联动逻辑
    seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
        @Override
        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
            int value = progress + min;
            valueEditText.setText(String.valueOf(value));
            valueEditText.setSelection(valueEditText.getText().length());  // 保持光标在末尾
            listener.onValueChanged(value);
            ConfigUtil.loadConfig(context);
            saveCurrentConfig(); // 保存当前配置
        }

        @Override
        public void onStartTrackingTouch(SeekBar seekBar) {}

        @Override
        public void onStopTrackingTouch(SeekBar seekBar) {}
    });

    valueEditText.addTextChangedListener(new TextWatcher() {
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            try {
                int value = Integer.parseInt(s.toString());
                if (value >= min && value <= max) {
                    seekBar.setProgress(value - min);
                    listener.onValueChanged(value);
                    saveCurrentConfig(); // 保存当前配置
                }
            } catch (NumberFormatException ignored) {}
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

        @Override
        public void afterTextChanged(Editable s) {
            // 保持光标在末尾
            valueEditText.setSelection(valueEditText.getText().length());
        }
    });

    parent.addView(layout);
}

    
    
    //浮点
    private void addFloatSeekBarWithEditText(Context context, LinearLayout parent, String label, float initialValue, float min, float max, FloatValueChangeListener listener) {
    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(LinearLayout.HORIZONTAL);
    layout.setLayoutParams(new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
    ));
    layout.setPadding(8, 4, 8, 4);

    TextView labelView = new TextView(context);
    labelView.setText(label);
    labelView.setTextSize(10); // 小字体
    labelView.setTextColor(Color.parseColor("#B9A6FF"));
    labelView.setGravity(Gravity.CENTER_VERTICAL);
    labelView.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 1.2f));
    layout.addView(labelView);

    // 设置 SeekBar 居中
    SeekBar seekBar = new SeekBar(context);
    LinearLayout.LayoutParams seekBarParams = new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 2f);
    seekBarParams.setMargins(0, 20, 0, 0); // 调整上下边距以居中
    seekBar.setLayoutParams(seekBarParams);
    seekBar.setMax((int) ((max - min) * 1_000));  // 这里乘以 1,000,000,000 保留 10 位小数精度
    seekBar.setProgress((int) ((initialValue - min) * 1_000)); // 初始化时也需要乘以精度
    seekBar.getThumb().setColorFilter(Color.parseColor("#6F5A9A"), android.graphics.PorterDuff.Mode.SRC_IN);
    seekBar.getProgressDrawable().setColorFilter(Color.parseColor("#A390E4"), android.graphics.PorterDuff.Mode.SRC_IN);
    layout.addView(seekBar);

    // 配置带圆角背景的输入框
    EditText valueEditText = new EditText(context);
    valueEditText.setText(String.format("%.3f", initialValue));  // 显示 3位小数
    valueEditText.setTextSize(10);
    valueEditText.setTextColor(Color.parseColor("#B9A6FF"));
    valueEditText.setGravity(Gravity.CENTER);

    // 设置输入框圆角背景
    GradientDrawable editTextBackground = new GradientDrawable();
    editTextBackground.setColor(Color.parseColor("#3A355A")); // 背景颜色
    editTextBackground.setCornerRadius(16); // 圆角半径
    valueEditText.setBackground(editTextBackground);

    valueEditText.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 0.8f));
    layout.addView(valueEditText);

    // 滑动条和输入框的联动逻辑
    seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
        @Override
        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
            // 计算浮动值，progress 被放大 1_000 倍来保持精度
            float value = min + (progress / 1_000.0f);
            valueEditText.setText(String.format("%.3f", value)); // 更新输入框的显示
            listener.onValueChanged(value);  // 传递浮动数值给监听器
            saveCurrentConfig(); // 保存当前配置
        }

        @Override
        public void onStartTrackingTouch(SeekBar seekBar) {}

        @Override
        public void onStopTrackingTouch(SeekBar seekBar) {}
    });

    valueEditText.addTextChangedListener(new TextWatcher() {
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            try {
                // 获取浮动数值
                float value = Float.parseFloat(s.toString());
                if (value >= min && value <= max) {
                    // 使用浮动数值更新 SeekBar 进度
                    int progress = (int) ((value - min) * 1_000); // 保留  位小数的浮动处理
                    seekBar.setProgress(progress); // 更新滑动条进度
                    listener.onValueChanged(value);  // 传递浮动数值给监听器
                    saveCurrentConfig(); // 保存当前配置
                }
            } catch (NumberFormatException ignored) {}
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

        @Override
        public void afterTextChanged(Editable s) {
            valueEditText.setSelection(valueEditText.getText().length());
        }
    });

    parent.addView(layout);
}

private void addDoubleSeekBarWithEditText(Context context, LinearLayout parent, String label, double initialValue, double min, double max, DoubleValueChangeListener listener) {
    // 使用大范围的缩放因子，支持小数点后 10 位
    int precisionScale = 1_000_000; // 支持小数点后 6 位


    LinearLayout layout = new LinearLayout(context);
    layout.setOrientation(LinearLayout.HORIZONTAL);
    layout.setLayoutParams(new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
    ));
    layout.setPadding(8, 4, 8, 4);

    TextView labelView = new TextView(context);
    labelView.setText(label);
    labelView.setTextSize(10); // 小字体
    labelView.setTextColor(Color.parseColor("#B9A6FF"));
    labelView.setGravity(Gravity.CENTER_VERTICAL);
    labelView.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 1.2f));
    layout.addView(labelView);

    // 设置 SeekBar
    SeekBar seekBar = new SeekBar(context);
    LinearLayout.LayoutParams seekBarParams = new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 2f);
    seekBarParams.setMargins(0, 20, 0, 0); // 调整上下边距以居中
    seekBar.setLayoutParams(seekBarParams);
    seekBar.setMax((int) ((max - min) * precisionScale));  // 放大到 10^9 范围
    seekBar.setProgress((int) ((initialValue - min) * precisionScale)); // 初始化时放大
    seekBar.getThumb().setColorFilter(Color.parseColor("#6F5A9A"), android.graphics.PorterDuff.Mode.SRC_IN);
    seekBar.getProgressDrawable().setColorFilter(Color.parseColor("#A390E4"), android.graphics.PorterDuff.Mode.SRC_IN);
    layout.addView(seekBar);

    // 配置输入框
    EditText valueEditText = new EditText(context);
    valueEditText.setText(String.format("%.10f", initialValue));  // 显示 10 位小数
    valueEditText.setTextSize(10);
    valueEditText.setTextColor(Color.parseColor("#B9A6FF"));
    valueEditText.setGravity(Gravity.CENTER);

    // 设置输入框圆角背景
    GradientDrawable editTextBackground = new GradientDrawable();
    editTextBackground.setColor(Color.parseColor("#3A355A")); // 背景颜色
    editTextBackground.setCornerRadius(16); // 圆角半径
    valueEditText.setBackground(editTextBackground);

    valueEditText.setLayoutParams(new LinearLayout.LayoutParams(0, LayoutParams.WRAP_CONTENT, 0.8f));
    layout.addView(valueEditText);

    // 联动逻辑：SeekBar -> EditText
    seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
        @Override
        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
            // 计算浮动值，进度值除以缩放因子
            double value = min + (progress / (double) precisionScale);
            valueEditText.setText(String.format("%.10f", value)); // 更新输入框
            listener.onValueChanged(value);  // 回调监听器
        }

        @Override
        public void onStartTrackingTouch(SeekBar seekBar) {}

        @Override
        public void onStopTrackingTouch(SeekBar seekBar) {}
    });

    // 联动逻辑：EditText -> SeekBar
    valueEditText.addTextChangedListener(new TextWatcher() {
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            try {
                // 获取双精度浮动值
                double value = Double.parseDouble(s.toString());
                if (value >= min && value <= max) {
                    // 将浮动值转换为 SeekBar 的进度
                    int progress = (int) ((value - min) * precisionScale);
                    seekBar.setProgress(progress); // 更新滑动条进度
                    listener.onValueChanged(value);  // 回调监听器
                }
            } catch (NumberFormatException ignored) {}
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

        @Override
        public void afterTextChanged(Editable s) {}
    });

    parent.addView(layout);
}

public interface DoubleValueChangeListener {
    void onValueChanged(double value);
}



    // 保存配置方法
    private void saveCurrentConfig() {
        ConfigUtil.saveConfigToTargetAppDir(parameters);
    }
    private void updateMenuHighlight(int pageIndex) {
        resetMenuBackground(gameSettings);
        resetMenuBackground(skinSettings);
        resetMenuBackground(operationSettings);
        resetMenuBackground(advancedSettings);

        if (pageIndex == 0) {
            setRoundedBackground(gameSettings, "#6F5A9A");
        } else if (pageIndex == 1) {
            setRoundedBackground(skinSettings, "#6F5A9A");
        } else if (pageIndex == 2) {
            setRoundedBackground(operationSettings, "#6F5A9A");
        } else if (pageIndex == 3) {
            setRoundedBackground(advancedSettings, "#6F5A9A");
        }
    }
    private void resetMenuBackground(TextView textView) {
        textView.setBackgroundColor(Color.TRANSPARENT);
    }

    private void setRoundedBackground(TextView textView, String color) {
        GradientDrawable roundedBackground = new GradientDrawable();
        roundedBackground.setColor(Color.parseColor(color));
        roundedBackground.setCornerRadius(dpToPx(16));
        textView.setBackground(roundedBackground);
    }

    // 接口用于实时更新参数值
    interface ValueChangeListener {
        void onValueChanged(int value);
    }

    // 浮动值
    interface FloatValueChangeListener {
    void onValueChanged(float value); 
    }

    private void applySwitchStyle(Switch switchButton) {
        switchButton.getThumbDrawable().setColorFilter(Color.parseColor("#6F5A9A"), PorterDuff.Mode.SRC_IN); // 紫色滑块
        switchButton.getTrackDrawable().setColorFilter(Color.parseColor("#A390E4"), PorterDuff.Mode.SRC_IN); // 浅紫色轨道
    }
    private void showToast(Context context, String message) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
    }

    // 辅助方法：转换 dp 为 px
    private int dpToPx(int dp) {
        float density = getContext().getResources().getDisplayMetrics().density;
        return (int) (dp * density + 0.5f);
    }
    // 接口定义
    public interface CollapsibleContentProvider {
    LinearLayout provideContent();
    }


    // 辅助接口：提供可折叠区域的内容
    interface CollapsibleSectionContentProvider {
        View provideContent();
        
    }
    
private void 三角() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }
    
    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {

                if (initialAngle == null) { initialAngle = joystickAngle; }
                // 执行三角操作
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.三角1滑动角度, parameters.三角1滑动长度, parameters.三角1滑动时长, 触摸id,w1);
                Thread.sleep(parameters.三角1点击延时); 

                // 按下和抬起
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.三角2滑动延时); 

                // 第二次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.三角2滑动角度, parameters.三角2滑动长度, parameters.三角2滑动时长, 触摸id,w1);
                Thread.sleep(parameters.三角2点击延时);

                // 按下和抬起
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.三角3滑动延时);

                // 第三次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.三角3滑动角度, parameters.三角3滑动长度, parameters.三角3滑动时长, 触摸id,w1);
                    
                // 循环点击
                for (int i = 0; i < parameters.三角分身次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.三角分身延时);
                }
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                 HOOK.TouchEventHandler.抬起(simpleButtonController.摇杆x, simpleButtonController.摇杆x, 点击id);
    
                    }
                });

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

private void 蛇手左() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {

                if (initialAngle == null) { initialAngle = joystickAngle; }
                // 执行蛇手左操作
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手左滑动1角度, parameters.蛇手左滑动1长度, parameters.蛇手左滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.蛇手左分身延时1); 

                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.蛇手左滑动延时2);

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手左滑动2角度, parameters.蛇手左滑动2长度, parameters.蛇手左滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.蛇手左分身延时2);
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.蛇手左滑动延时3); // 延时
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手左滑动3角度, parameters.蛇手左滑动3长度, parameters.蛇手左滑动3时长, 触摸id,w1);

                // 循环按下和抬起
                for (int i = 0; i < parameters.蛇手左分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.蛇手左分身点击延时);
                }
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

private void 蛇手右() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {

                if (initialAngle == null) { initialAngle = joystickAngle; }
                // 执行蛇手右操作
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手右滑动1角度, parameters.蛇手右滑动1长度, parameters.蛇手右滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.蛇手右分身延时1);
                        
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.蛇手右滑动延时2);

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手右滑动2角度, parameters.蛇手右滑动2长度, parameters.蛇手右滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.蛇手右分身延时2);
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.蛇手右滑动延时3); // 延时
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.蛇手右滑动3角度, parameters.蛇手右滑动3长度, parameters.蛇手右滑动3时长, 触摸id,w1);

                // 循环按下和抬起
                for (int i = 0; i < parameters.蛇手右分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.蛇手右分身点击延时);
                }
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

private void 四分测合左() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
               
                if (initialAngle == null) { initialAngle = joystickAngle; }


                // 第一次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.四分测合左1角度, parameters.四分测合左1滑动长度, parameters.四分测合左1滑动时长, 触摸id,w1);
                Thread.sleep(parameters.四分测合左2分前延时); // 延时
                for(int i = 0; i < 2; ++i) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                	HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.四分测合左2分身延时); // 延时
                }
                Thread.sleep(parameters.四分测合左2分后延时); // 延时

                // 第二次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.四分测合左2角度, parameters.四分测合左2滑动长度, parameters.四分测合左2滑动时长, 触摸id,w1);

                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.四分测合左点击分身次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.四分测合左点击延时); // 延时
                }
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

private void 四分测合右() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                        
                if (initialAngle == null) {
                    initialAngle = joystickAngle;
                }


                // 第一次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.四分测合右1角度, parameters.四分测合右1滑动长度, parameters.四分测合右1滑动时长, 触摸id,w1);
                Thread.sleep(parameters.四分测合右2分前延时); // 延时
                for(int i = 0; i < 2; ++i) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                	HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.四分测合右2分延时); // 延时
                }
                Thread.sleep(parameters.四分测合右2分后延时); // 延时

                // 第二次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.四分测合右2角度, parameters.四分测合右2滑动长度, parameters.四分测合右2滑动时长, 触摸id,w1);
                

                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.四分测合右点击分身次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.四分测合右点击延时); // 延时
                }
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

private void 后仰左() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                // 确保 initialAngle 被正确初始化
                if (initialAngle == null) {
                    initialAngle = joystickAngle;
                }

                // 第一次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰左滑动1角度, parameters.后仰左滑动1长度, parameters.后仰左滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.后仰左分身延时1); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.后仰左滑动延时2); // 延时
                // 第二次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰左滑动2角度, parameters.后仰左滑动2长度, parameters.后仰左滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.后仰左分身延时2); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.后仰左滑动延时3); // 延时

                // 第三次滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰左滑动3角度, parameters.后仰左滑动3长度, parameters.后仰左滑动3时长, 触摸id,w1);

                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.后仰左分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.后仰左分身点击延时); // 延时
                }

                // 恢复 initialAngle
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}


private void 后仰右() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                        
                if (initialAngle == null) {
                    initialAngle = joystickAngle;
                }

                // 使用定义的参数进行滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰右滑动1角度, parameters.后仰右滑动1长度, parameters.后仰右滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.后仰右分身延时1); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.后仰右滑动延时2); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰右滑动2角度, parameters.后仰右滑动2长度, parameters.后仰右滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.后仰右分身延时2); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.后仰右滑动延时3); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.后仰右滑动3角度, parameters.后仰右滑动3长度, parameters.后仰右滑动3时长, 触摸id,w1);

                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.后仰右分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.后仰右分身点击延时); // 延时
                }

                // 重置角度
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}
    
    private void 旋转右() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                        
                if (initialAngle == null) {
                    initialAngle = joystickAngle;
                }

                // 使用定义的参数进行滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转右滑动1角度, parameters.旋转右滑动1长度, parameters.旋转右滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.旋转右分身延时1); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转右滑动延时2); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转右滑动2角度, parameters.旋转右滑动2长度, parameters.旋转右滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.旋转右分身延时2); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转右滑动延时3); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转右滑动3角度, parameters.旋转右滑动3长度, parameters.旋转右滑动3时长, 触摸id,w1);
                Thread.sleep(parameters.旋转右分身延时3); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转右滑动延时4); // 延时
                        
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转右滑动4角度, parameters.旋转右滑动4长度, parameters.旋转右滑动4时长, 触摸id,w1);
                Thread.sleep(parameters.旋转右摇杆点击延时4); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);

                Thread.sleep(parameters.旋转右分身连击延时); // 延时
             
                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.后仰右分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.后仰右分身点击延时); // 延时
                }

                // 重置角度
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

    
    private void 旋转左() {
    if (isRunning) {
        return;  // 如果当前操作正在执行，则不做任何事情
    }

    isRunning = true;  // 标记为正在执行

    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                if (initialAngle == null) {
                    initialAngle = joystickAngle;
                }

                // 使用定义的参数进行滑动
                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转左滑动1角度, parameters.旋转左滑动1长度, parameters.旋转左滑动1时长, 触摸id,w1);
                Thread.sleep(parameters.旋转左分身延时1); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转左滑动延时2); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转左滑动2角度, parameters.旋转左滑动2长度, parameters.旋转左滑动2时长, 触摸id,w1);
                Thread.sleep(parameters.旋转左分身延时2); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转左滑动延时3); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转左滑动3角度, parameters.旋转左滑动3长度, parameters.旋转左滑动3时长, 触摸id,w1);
                Thread.sleep(parameters.旋转左分身延时3); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                Thread.sleep(parameters.旋转左滑动延时4); // 延时

                HOOK.TouchEventHandler.角度滑动(simpleButtonController.摇杆x, simpleButtonController.摇杆y, initialAngle, parameters.旋转左滑动4角度, parameters.旋转左滑动4长度, parameters.旋转左滑动4时长, 触摸id,w1);
                Thread.sleep(parameters.旋转左摇杆点击延时4); // 延时
                HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);

                Thread.sleep(parameters.旋转左分身连击延时); // 延时

                // 循环按下和抬起，带有延时
                for (int i = 0; i < parameters.旋转左分身点击次数; i++) {
                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
                    Thread.sleep(parameters.旋转左分身点击延时); // 延时
                }

                // 重置角度
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        initialAngle = null;
                    }
                });

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 操作完成后恢复标志位
                isRunning = false;
            }
        }
    }).start();
}

   private void 黑屏值(Context context) {
    new Thread(() -> {
        try {
            // 定义文件名
            String fileName = "memory_value.txt";

            // 初始化文件路径，并确保文件存在，默认值为800
            文件读写.写入(context, fileName, "800", false, false); // 确保文件存在且初始化为 "800"

            long q1 = a3 - 104;

            while (true) {
                // 每隔500ms检查一次文件内容
                String value = 文件读写.读取(context, fileName, String.class);

                // 如果文件有内容，进行写入操作
                if (value != null && !value.isEmpty()) {
                    // 写入内存
                    memory.setValue(value, q1, memory.TYPE_FLOAT);

                    // 清空文件内容，防止重复执行
                    文件读写.写入(context, fileName, "", false, false);
                }

                // 每隔500ms再次检查文件
                Thread.sleep(50);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
}).start();
}


    
    
    

//private void 内存卡点() {
//    new Thread(() -> {
//        try {
//            // 初始读取地址
//            int initialValue = memory.readDword(a2 - 208);
//            previousValue = initialValue;
//
//            while (true) {
//                // 每隔10毫秒读取一次当前地址的值
//                int currentValue = memory.readDword(a2 - 208);
//
//                // 判断值是否增加超过2
//                if (currentValue - previousValue > parameters.卡点过滤) {
//
//                 for (int i = 0; i < parameters.卡点分身次数; i++) {
//                    HOOK.TouchEventHandler.按下(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
//                    HOOK.TouchEventHandler.抬起(simpleButtonController.分身x, simpleButtonController.分身y, 点击id);
//                    Thread.sleep(parameters.卡点分身间隔); // 延时
//                
//                  }
//
//                    // 结束线程
//                    break;
//                }
//
//                // 更新之前的值
//                previousValue = currentValue;
//
//                Thread.sleep(parameters.卡点循环判断);
//            }
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//    }).start();
//}

    
// 定义全局字符串变量，用于存储结果
private static String resultData;

// 方法：获取公告
public static void getAnnouncement(final Context context) {
    wy.公告(context, new wy.Callback() {
        @Override
        public void onResult(String result) {
            resultData = result; // 将公告内容存储到变量中
        }

        @Override
        public void onError(Exception e) {
            resultData = "公告获取失败: " + e.getMessage(); // 存储错误信息
        }
    });
}

  public static long[] 提取偏移链(String input) {
    if (input == null || input.isEmpty()) {
        return new long[0]; // 返回空数组
    }

    try {
        // 去掉字符串中的非数字和逗号部分
        input = input.replaceAll("[^0-9A-Fa-fx,]", "").trim();

        // 按逗号分割
        String[] hexValues = input.split(",");

        // 转换为 long 数组
        long[] offsets = new long[hexValues.length];
        for (int i = 0; i < hexValues.length; i++) {
            offsets[i] = Long.decode(hexValues[i].trim()); // 支持 0x 开头的十六进制转换
        }

        return offsets;
    } catch (Exception e) {
        Log.e("提取偏移链", "解析失败: " + e.getMessage());
        return new long[0]; // 如果解析失败返回空数组
    }
}
    public static long[] 提取字符(String input) {
    if (input == null || input.isEmpty()) {
        return new long[0]; // 返回空数组
    }

    try {
        // 去掉字符串中的非数字和逗号部分
        input = input.replaceAll("[^0-9A-Fa-fx,]", "").trim();

        // 按逗号分割
        String[] hexValues = input.split(",");

        // 转换为 long 数组
        long[] offsets = new long[hexValues.length];
        for (int i = 0; i < hexValues.length; i++) {
            offsets[i] = Long.decode(hexValues[i].trim()); // 支持 0x 开头的十六进制转换
        }

        return offsets;
    } catch (Exception e) {
        Log.e("提取偏移链", "解析失败: " + e.getMessage());
        return new long[0]; // 如果解析失败返回空数组
    }
}

        
        // 将 long[] 数组转换为字符串的方法
public static String 数组转字符串(long[] array) {
    if (array == null || array.length == 0) {
        return "空数组";
    }

    StringBuilder result = new StringBuilder();
    for (long value : array) {
        result.append(String.format("0x%X, ", value)); // 格式化为十六进制
    }

    // 去掉最后的逗号和空格
    return result.substring(0, result.length() - 2);
}

    public static int 提取变量(String input) {
        if (input == null || input.isEmpty()) {
            throw new IllegalArgumentException("输入字符串不能为空");
        }

        // 匹配引号中的数字，例如 "96"
        String regex = "\"msg\":\"(\\d+)\"";
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(regex);
        java.util.regex.Matcher matcher = pattern.matcher(input);

        // 查找匹配
        if (matcher.find()) {
            // 提取第一个捕获组中的数字并转换为 int 类型
            return Integer.parseInt(matcher.group(1));
        }

        // 如果没有匹配到数字，返回 -1 或其他默认值
        return -1;
    }
    
    
    
    
/// 定义一个全局变量用于显示刷新率和 FPS
TextView fpsTextView;
private Choreographer.FrameCallback frameCallback;
private int 捕获画面FPS = 0; // 捕获画面获取的刷新率

private void monitorRootViewDrawFrequency(View rootView) {
    // 初始化 TextView，用于显示 FPS 和刷新率
    fpsTextView = new TextView(rootView.getContext());
    fpsTextView.setTextColor(Color.RED);
    fpsTextView.setTextSize(16);
    fpsTextView.setBackgroundColor(Color.argb(128, 0, 0, 0)); // 半透明背景

    // 将 TextView 添加到根布局
    if (rootView instanceof ViewGroup) {
        ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
        );
        ((ViewGroup) rootView).addView(fpsTextView, params);
    }

    // 获取设备支持的屏幕刷新率
    final float refreshRate = ((WindowManager) rootView.getContext().getSystemService(Context.WINDOW_SERVICE))
            .getDefaultDisplay()
            .getRefreshRate(); // 真实的设备刷新率，例如 120Hz 或 60Hz

    // 使用 Choreographer 来统计 FPS
    frameCallback = new Choreographer.FrameCallback() {
        private long lastFrameTimeNanos = 0; // 上一次帧的时间
        private int frameCount = 0;         // 帧计数

        @Override
        public void doFrame(long frameTimeNanos) {
            if (lastFrameTimeNanos == 0) {
                lastFrameTimeNanos = frameTimeNanos;
            }

            frameCount++;

            // 计算时间间隔是否超过 1 秒
            if ((frameTimeNanos - lastFrameTimeNanos) >= 1_000_000_000L) { // 1 秒 = 10^9 纳秒
                int appFPS = frameCount; // 当前应用帧率
                frameCount = 0;          // 重置帧计数
                lastFrameTimeNanos = frameTimeNanos;

                // 更新 TextView 显示
                fpsTextView.setText(String.format(
                        "刷新率: %.1f Hz\nFPS: 当前应用刷新率 %d + 捕获画面刷新率 %d\n捕获画面实际刷新率: %d",
                        refreshRate, appFPS, 捕获画面FPS, 捕获画面FPS));
            }

            // 注册下一帧回调
            Choreographer.getInstance().postFrameCallback(this);
        }
    };

    // 启动帧回调
    Choreographer.getInstance().postFrameCallback(frameCallback);

    // 启动捕获画面 FPS 检测
    捕获画面.startFPSDetection(16, new 捕获画面.FPSCallback() {
        @Override
        public void onFPSDetected(int fps) {
            // 更新捕获画面的刷新率
            捕获画面FPS = fps;
        }
    });
}
            
            
            
            
// 全局变量
private boolean 允许运行 = false; // 控制线程是否可以正常运行

public void 绘制目标球体(int 目标排名ID) {
    new Thread(() -> {
        boolean 已检测到分裂 = false; // 用于标记是否已经检测到目标球体分裂
        while (允许运行) { // 线程运行受全局变量控制
            try {
                // 清除之前绘制的形状
                drawView.clearAllShapes();

                // 用于记录目标排名ID的最大体积球体
                int 目标序号 = -1;
                float 最大半径 = -1;
                int 相同排名ID数量 = 0; // 用于统计相同排名ID的球体数量

                // 遍历玩家信息列表
                for (int i = 0; i < 玩家信息列表.size(); i++) {
                    String 玩家信息 = 玩家信息列表.get(i);

                    try {
                        // 解析玩家信息中的编号、坐标和半径
                        String[] parts = 玩家信息.split(" ");
                        String 编号部分 = parts[0].replace(".", ""); // "1."
                        int 编号 = Integer.parseInt(编号部分);
                        float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                        float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                        float radius = Float.parseFloat(parts[3].replace("半径=", ""));
                        int rankId = Integer.parseInt(parts[4].replace("排名ID=", ""));

                        // 判断是否为目标排名ID
                        if (rankId == 目标排名ID) {
                            相同排名ID数量++; // 统计目标排名ID的球体数量

                            // 判断是否为最大半径球体
                            if (radius > 最大半径) {
                                最大半径 = radius;
                                目标序号 = 编号;
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace(); // 处理解析失败的异常
                    }
                }

                // 判断目标球体是否一分为二
                if (相同排名ID数量 >= 2 && !已检测到分裂) {
                    已检测到分裂 = true; // 标记已经检测到分裂


                    // 结束当前线程
                    break;
                }

                // 如果找到了目标球体，计算屏幕坐标并绘制
                if (目标序号 != -1) {
                    for (int i = 0; i < 玩家信息列表.size(); i++) {
                        String 玩家信息 = 玩家信息列表.get(i);

                        try {
                            // 解析玩家信息中的编号、坐标和半径
                            String[] parts = 玩家信息.split(" ");
                            String 编号部分 = parts[0].replace(".", ""); // "1."
                            int 编号 = Integer.parseInt(编号部分);
                            float screenX = Float.parseFloat(parts[1].replace("X=", ""));
                            float screenY = Float.parseFloat(parts[2].replace("Y=", ""));
                            float radius = Float.parseFloat(parts[3].replace("半径=", ""));

                            // 如果是目标序号，进行绘制
                            if (编号 == 目标序号) {
                                // 屏幕中心坐标与比例
                                float 屏幕中心相对地图的x = memory.readFloat(a3 - 100);
                                float 屏幕中心相对地图的y = 200 - memory.readFloat(a3 - 96);

                                float startX = parameters.分辨率x / 2;
                                float startY = parameters.分辨率y / 2;

                                // 计算屏幕坐标
                                float screenXa = ((screenX - 屏幕中心相对地图的x)
                                        * 23.25f * parameters.比例
                                        * (23.25f * parameters.比例 / 视图比例)) + startX;
                                float screenYa = ((screenY - 屏幕中心相对地图的y)
                                        * 23.25f * parameters.比例
                                        * (23.25f * parameters.比例 / 视图比例)) + startY;

                                // 绘制球体
                                drawView.addCircle(
                                        screenXa,
                                        screenYa,
                                        radius * 23.25f * parameters.比例 * (23.25f * parameters.比例 / 视图比例),
                                        Color.YELLOW,
                                        6f
                                );
                                break; // 已找到并绘制，退出循环
                            }
                        } catch (Exception e) {
                            e.printStackTrace(); // 处理解析失败的异常
                        }
                    }
                }

                // 每10毫秒刷新一次
                Thread.sleep(10);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
}

    


}
